//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
// Suppress warnings about obsolete types and members
// in generated code
#pragma warning disable CS0612, CS0618

namespace System.Runtime.CompilerServices
{
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.OpenApi.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.OpenApi;
    using Microsoft.AspNetCore.Mvc.Controllers;
    using Microsoft.AspNetCore.Mvc.ModelBinding.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.OpenApi;

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file record XmlComment(
        string? Summary,
        string? Description,
        string? Remarks,
        string? Returns,
        string? Value,
        bool Deprecated,
        List<string>? Examples,
        List<XmlParameterComment>? Parameters,
        List<XmlResponseComment>? Responses);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file record XmlParameterComment(string? Name, string? Description, string? Example, bool Deprecated);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file record XmlResponseComment(string Code, string? Description, string? Example);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file static class XmlCommentCache
    {
        private static Dictionary<string, XmlComment>? _cache;
        public static Dictionary<string, XmlComment> Cache => _cache ??= GenerateCacheEntries();

        private static Dictionary<string, XmlComment> GenerateCacheEntries()
        {
            var cache = new Dictionary<string, XmlComment>();
            cache.Add(@"T:FastEndpoints.BindFromAttribute", new XmlComment(@"use this attribute to specify the name of route param, query param, or form field if it's different from the name of the property being bound to.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindFromAttribute.Name", new XmlComment(@"the name of the incoming query param, route param or form field", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BindFromAttribute.#ctor(System.String)", new XmlComment(@"use this attribute to specify the name of route param, query param, or form field if it's different from the name of the property being bound to.", null, null, null, null, false, null, [new XmlParameterComment(@"name", @"the name to use for binding", null, false)], null));
            cache.Add(@"T:FastEndpoints.NonJsonBindingAttribute", new XmlComment(@"", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.DontBindAttribute", new XmlComment(@"you can prevent one or more binding sources from supplying values for a dto property decorated with this attribute.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.DontBindAttribute.BindingSources", new XmlComment(@"gets the disabled binding sources.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.DontBindAttribute.IsRequired", new XmlComment(@"set to true if a validation error should be thrown when the request doesn't have a value for this property.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.DontBindAttribute.#ctor(FastEndpoints.Source)", new XmlComment(@"specify a bitwise combination of binding sources to disable for the property.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.FormFieldAttribute", new XmlComment(@"disables all other binding sources for a dto property except form fields.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.FormFieldAttribute.#ctor", new XmlComment(@"disables all other binding sources for a dto property except form fields.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RouteParamAttribute", new XmlComment(@"disables all other binding sources for a dto property except route params.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RouteParamAttribute.#ctor", new XmlComment(@"disables all other binding sources for a dto property except route params.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.QueryParamAttribute", new XmlComment(@"disables all other binding sources for a dto property except query params.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.QueryParamAttribute.#ctor", new XmlComment(@"disables all other binding sources for a dto property except query params.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.FromAttribute", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal.
this is a shorter alias for the [FromClaim] attribute.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.FromAttribute.#ctor(System.String,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal.
this is a shorter alias for the [FromClaim] attribute.", null, null, null, null, false, null, [new XmlParameterComment(@"claimType", @"the claim type to auto bind", null, false), new XmlParameterComment(@"isRequired", @"set to true if a validation error should be thrown when the current user principal doesn't have the specified claim", null, false)], null));
            cache.Add(@"T:FastEndpoints.FromBodyAttribute", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the incoming request's json body.
HINT: no other binding sources will be used for binding that property.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.FromClaimAttribute", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromClaimAttribute.ClaimType", new XmlComment(@"the claim type to auto bind", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromClaimAttribute.IsRequired", new XmlComment(@"set to true if a validation error should be thrown when the current user principal doesn't have the specified claim", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromClaimAttribute.RemoveFromSchema", new XmlComment(@"set to true if your header is not required but shouldn't be added to schema model", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.FromClaimAttribute.#ctor(System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal", null, null, null, null, false, null, [new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current user principal doesn't have a claim type matching the property name
being bound to.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your header is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"M:FastEndpoints.FromClaimAttribute.#ctor(System.String,System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal", null, null, null, null, false, null, [new XmlParameterComment(@"claimType", @"optionally specify the claim type to bind from. if not specified, the claim type of the user principal must match the name of the property being
bound to.", null, false), new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current user principal doesn't have the specified claim type", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your header is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"T:FastEndpoints.FromCookieAttribute", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant cookie of the current request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromCookieAttribute.CookieName", new XmlComment(@"the cookie name to auto bind from", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromCookieAttribute.IsRequired", new XmlComment(@"set to true if a validation error should be thrown when the current request doesn't have the specified cookie", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromCookieAttribute.RemoveFromSchema", new XmlComment(@"set to true if your cookie is not required but shouldn't be added to schema model", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.FromCookieAttribute.#ctor(System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant http cookie of the current request.", null, null, null, null, false, null, [new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current user request doesn't have a cookie matching the property name being
bound to.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your cookie is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"M:FastEndpoints.FromCookieAttribute.#ctor(System.String,System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant http cookie of the current request.", null, null, null, null, false, null, [new XmlParameterComment(@"cookieName", @"optionally specify the cookie name to bind from. if not specified, the cookie name must match the name of the property being bound to.", null, false), new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current request doesn't have the specified cookie.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your cookie is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"T:FastEndpoints.FromFormAttribute", new XmlComment(@"            if a request dto property is decorated with this attribute, that property will be bound from complex multipart form data (including files) from the
            incoming request. only valid on complex type properties. only one dto property can be decorated. the incoming form data should be in the correct format.
            incoming content-type must be `multipart/form-data`HINT: recursively binding complex object graphs from form data is less performant than binding to top level dto properties.
so... use sparingly!", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.FromHeaderAttribute", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant http header of the current request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromHeaderAttribute.HeaderName", new XmlComment(@"the header name to auto bind from", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromHeaderAttribute.IsRequired", new XmlComment(@"set to true if a validation error should be thrown when the current request doesn't have the specified header", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.FromHeaderAttribute.RemoveFromSchema", new XmlComment(@"set to true if your header is not required but shouldn't be added to schema model", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.FromHeaderAttribute.#ctor(System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant http header of the current request.", null, null, null, null, false, null, [new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current user request doesn't have a header matching the property name being
bound to.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your header is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"M:FastEndpoints.FromHeaderAttribute.#ctor(System.String,System.Boolean,System.Boolean)", new XmlComment(@"properties decorated with this attribute will have their values auto bound from the relevant http header of the current request.", null, null, null, null, false, null, [new XmlParameterComment(@"headerName", @"optionally specify the header name to bind from. if not specified, the header name must match the name of the property being bound to.", null, false), new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current request doesn't have the specified header.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your header is not required but shouldn't be added to schema model.", null, false)], null));
            cache.Add(@"T:FastEndpoints.FromQueryAttribute", new XmlComment(@"            if a request dto property is decorated with this attribute, that property will be bound from complex query parameter data from the  incoming request.
            only valid on complex type properties. only one dto property can be decorated. the incoming query parameters should be in the correct format.
            HINT: recursively binding complex object graphs from query parameters is less performant than binding to top level primitive dto properties.
so... use sparingly!", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HasPermissionAttribute", new XmlComment(@"boolean properties decorated with this attribute will have their values set to true if the current principal has the specified permission.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.HasPermissionAttribute.Permission", new XmlComment(@"the permission to check for", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.HasPermissionAttribute.IsRequired", new XmlComment(@"set to true if a validation error should be thrown when the current user principal doesn't have the specified permission", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.HasPermissionAttribute.RemoveFromSchema", new XmlComment(@"set to true if your header is not required but shouldn't be added to model", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HasPermissionAttribute.#ctor(System.String,System.Boolean,System.Boolean)", new XmlComment(@"boolean properties decorated with this attribute will have their values set to true if the current principal has the specified permission.", null, null, null, null, false, null, [new XmlParameterComment(@"permission", @"the permission to check for", null, false), new XmlParameterComment(@"isRequired", @"set to false if a validation error shouldn't be thrown when the current principal doesn't have the specified permission.", null, false), new XmlParameterComment(@"removeFromSchema", @"set to true if your header is not required but shouldn't be added to body model.", null, false)], null));
            cache.Add(@"T:FastEndpoints.AllowFileUploadsAttribute", new XmlComment(@"enable file uploads with multipart/form-data content type", null, null, null, null, false, null, [new XmlParameterComment(@"dontAutoBindFormData", @"set 'true' to disable auto binding of form data which enables uploading and reading of large files without buffering to memory/disk.
you can access the multipart sections for reading via the `FormFileSectionsAsync()` method.", null, false)], null));
            cache.Add(@"M:FastEndpoints.AllowFileUploadsAttribute.#ctor(System.Boolean)", new XmlComment(@"enable file uploads with multipart/form-data content type", null, null, null, null, false, null, [new XmlParameterComment(@"dontAutoBindFormData", @"set 'true' to disable auto binding of form data which enables uploading and reading of large files without buffering to memory/disk.
you can access the multipart sections for reading via the `FormFileSectionsAsync()` method.", null, false)], null));
            cache.Add(@"P:FastEndpoints.AllowFileUploadsAttribute.DontAutoBindFormData", new XmlComment(@"set 'true' to disable auto binding of form data which enables uploading and reading of large files without buffering to memory/disk.
you can access the multipart sections for reading via the `FormFileSectionsAsync()` method.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HttpAttribute", new XmlComment(@"base http attribute class", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HttpDeleteAttribute", new XmlComment(@"use this attribute to specify a DELETE route for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpDeleteAttribute.#ctor(System.String[])", new XmlComment(@"use this attribute to specify a DELETE route for an endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"routes", @"the routes for the endpoint", null, false)], null));
            cache.Add(@"T:FastEndpoints.HttpGetAttribute", new XmlComment(@"use this attribute to specify a GET route for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpGetAttribute.#ctor(System.String[])", new XmlComment(@"use this attribute to specify a GET route for an endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"routes", @"the routes for the endpoint", null, false)], null));
            cache.Add(@"T:FastEndpoints.HttpPatchAttribute", new XmlComment(@"use this attribute to specify a PATCH route for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpPatchAttribute.#ctor(System.String[])", new XmlComment(@"use this attribute to specify a PATCH route for an endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"routes", @"the routes for the endpoint", null, false)], null));
            cache.Add(@"T:FastEndpoints.HttpPostAttribute", new XmlComment(@"use this attribute to specify a POST route for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpPostAttribute.#ctor(System.String[])", new XmlComment(@"use this attribute to specify a POST route for an endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"routes", @"the routes for the endpoint", null, false)], null));
            cache.Add(@"T:FastEndpoints.HttpPutAttribute", new XmlComment(@"use this attribute to specify a PUT route for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpPutAttribute.#ctor(System.String[])", new XmlComment(@"use this attribute to specify a PUT route for an endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"routes", @"the routes for the endpoint", null, false)], null));
            cache.Add(@"T:FastEndpoints.ThrottleAttribute", new XmlComment(@"rate limit requests to this endpoint based on a request http header sent by the client.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ThrottleAttribute.HitLimit", new XmlComment(@"how many requests are allowed within the given duration", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ThrottleAttribute.DurationSeconds", new XmlComment(@"the frequency in seconds where the accrued hit count should be reset", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ThrottleAttribute.HeaderName", new XmlComment(@"the name of the request header used to uniquely identify clients.
header name can also be configured globally using `app.UseFastEndpoints(c=&gt; c.Throttle...)`
not specifying a header name will first look for 'X-Forwarded-For' header and if not present, will use `HttpContext.Connection.RemoteIpAddress`.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ThrottleAttribute.#ctor(System.Int32,System.Double,System.String)", new XmlComment(@"rate limit requests to this endpoint based on a request http header sent by the client.", null, null, null, null, false, null, [new XmlParameterComment(@"hitLimit", @"how many requests are allowed within the given duration", null, false), new XmlParameterComment(@"durationSeconds", @"the frequency in seconds where the accrued hit count should be reset", null, false), new XmlParameterComment(@"headerName", @"the name of the request header used to uniquely identify clients.
header name can also be configured globally using `app.UseFastEndpoints(c=&gt; c.ThrottleOptions...)`
not specifying a header name will first look for 'X-Forwarded-For' header and if not present, will use `HttpContext.Connection.RemoteIpAddress`.", null, false)], null));
            cache.Add(@"T:FastEndpoints.DontInjectAttribute", new XmlComment(@"endpoint properties marked with this attribute will disable property injection for that property", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.DontRegisterAttribute", new XmlComment(@"classes marked with this attribute will be skipped during assembly scanning for auto registration", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HideFromDocsAttribute", new XmlComment(@"attribute used to mark classes, properties, methods that should be hidden from public api", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.KeyedServiceAttribute", new XmlComment(@"use this attribute to mark a property to be auto injected from the DI container.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name", null, false)], null));
            cache.Add(@"M:FastEndpoints.KeyedServiceAttribute.#ctor(System.String)", new XmlComment(@"use this attribute to mark a property to be auto injected from the DI container.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name", null, false)], null));
            cache.Add(@"P:FastEndpoints.KeyedServiceAttribute.Key", new XmlComment(@"the key to use for obtaining the service from the DI container.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.NotImplementedAttribute", new XmlComment(@"indicates a base/abstract method that's not implemented.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RegisterServiceAttribute`1", new XmlComment(@"When using the 'FastEndpoints.Generator' package, any concrete class can be decorated with this attribute to source generate extension methods
in the form of `.RegisterServicesFrom{assembly-name}()` which can be used to automatically register services with a single call per assembly.
instead of multiple calls per each service you need registered in DI.
specify the service type with the TService generic attribute argument. the service type would typically be an interface type.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RegisterServiceAttribute`1.#ctor(FastEndpoints.LifeTime)", new XmlComment(@"mark a class for registration in DI using the 'FastEndpoints.Generator' package by specifying the service lifetime.", null, null, null, null, false, null, [new XmlParameterComment(@"serviceLifetime", @"the service lifetime to use when registering in DI", null, false)], null));
            cache.Add(@"T:FastEndpoints.LifeTime", new XmlComment(@"enum for selecting the DI service lifetime", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.LifeTime.Scoped", new XmlComment(@"scoped service lifetime", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.LifeTime.Transient", new XmlComment(@"transient service lifetime", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.LifeTime.Singleton", new XmlComment(@"singleton service lifetime", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ToHeaderAttribute", new XmlComment(@"response dto properties marked with this attribute will cause an automatic response header to be added to the http response with the value from the property  that is
annotated.", null, null, null, null, false, null, [new XmlParameterComment(@"headerName", @"a custom name for the header. if not supplied, the property name will be used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ToHeaderAttribute.#ctor(System.String)", new XmlComment(@"response dto properties marked with this attribute will cause an automatic response header to be added to the http response with the value from the property  that is
annotated.", null, null, null, null, false, null, [new XmlParameterComment(@"headerName", @"a custom name for the header. if not supplied, the property name will be used.", null, false)], null));
            cache.Add(@"P:FastEndpoints.ToHeaderAttribute.HeaderName", new XmlComment(@"a custom name for the header. if not supplied, the property name will be used.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ParseResult", new XmlComment(@"dto used to hold the result of a value parsing operation.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ParseResult.IsSuccess", new XmlComment(@"will be true if the parsing operation was a success", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ParseResult.Value", new XmlComment(@"will hold the parsed value if the parsing was successful", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ParseResult.#ctor(System.Boolean,System.Object)", new XmlComment(@"constructor for initializing a ParseResult instance", null, null, null, null, false, null, [new XmlParameterComment(@"isSuccess", @"set to true of parsing was successful", null, false), new XmlParameterComment(@"value", @"set the value that was obtained from the parsing operation", null, false)], null));
            cache.Add(@"T:FastEndpoints.ReflectionCache", new XmlComment(@"the central repository of reflection related data for request dtos and their children", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.TypeDefinition", new XmlComment(@"represents reflection data for a given type", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.TypeDefinition.ObjectFactory", new XmlComment(@"a func for creating a new blank instance of a type", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.TypeDefinition.Properties", new XmlComment(@"the reflection data for all the properties of a type", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.TypeDefinition.ValueParser", new XmlComment(@"a func used for converting string values to the respective type by calling it's `TryParse()` method.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.TypeDefinition.IsValidatable", new XmlComment(@"indicates if this type, or it's immediate properties has data annotation validation attributes.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PropertyDefinition", new XmlComment(@"represents reflection data for a property of a type", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PropertyDefinition.Setter", new XmlComment(@"action used for setting the value of a property on a class", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Http", new XmlComment(@"enum for specifying a http verb", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.GET", new XmlComment(@"retrieve a record", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.POST", new XmlComment(@"create a record", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.PUT", new XmlComment(@"replace a record", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.PATCH", new XmlComment(@"partially update a record", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.DELETE", new XmlComment(@"remove a record", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.HEAD", new XmlComment(@"retrieve only headers", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.OPTIONS", new XmlComment(@"retrieve communication options", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.CONNECT", new XmlComment(@"establish a communication tunnel", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Http.TRACE", new XmlComment(@"perform a message loop-back test for debugging purposes", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Source", new XmlComment(@"enum for choosing which binding sources to disable for a given property using the DontBindAttribute", null, null, null, null, false, null, null, null));

            cache.Add(@"T:FastEndpoints.IServiceResolverBase", new XmlComment(@"interface used by fastendpoints for resolving services from the DI container.
implement this interface and register the implementation in MS DI for customizing service resolving.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.CreateScope", new XmlComment(@"            if you'd like to resolve scoped or transient services from the MS DI container, obtain a service scope from this method and dispose the scope when
            the work is complete.
            ```using var scope = CreateScope();
var scopedService = scope.Resolve&lt;MyService&gt;();```", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.TryResolve``1", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.TryResolve(System.Type)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.Resolve``1", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.Resolve(System.Type)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.TryResolve``1(System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name for resolving keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.TryResolve(System.Type,System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"the key name for resolving keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.Resolve``1(System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name for resolving keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolverBase.Resolve(System.Type,System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"the key name for resolving keyed service", null, false)], null));
            cache.Add(@"T:FastEndpoints.IServiceResolver", new XmlComment(@"interface used by fastendpoints for resolving services from the DI container.
implement this interface and register the implementation in MS DI for customizing service resolving.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServiceResolver.CreateInstance(System.Type,System.IServiceProvider)", new XmlComment(@"create an instance of a given type (which may not be registered in the DI container). this method will be called repeatedly. so a cached
delegate/compiled expression using something like ObjectFactory ActivatorUtilities.CreateFactory(Type instanceType, Type[] argumentTypes) should be used for instance creation.", null, null, null, null, false, null, [new XmlParameterComment(@"type", @"the type to create an instance of", null, false), new XmlParameterComment(@"serviceProvider", @"optional service provider", null, false)], null));
            cache.Add(@"M:FastEndpoints.IServiceResolver.CreateSingleton(System.Type)", new XmlComment(@"create an instance of a given type (which may not be registered in the DI container) which will be used as a singleton. a utility such as
object ActivatorUtilities.CreateInstance(IServiceProvider provider, Type instanceType, params object[] parameters) may be used. repeated calls with the same input type should return the same
singleton
instance by utilizing an internal concurrent/thread-safe cache.", null, null, null, null, false, null, [new XmlParameterComment(@"type", @"the type to create an instance of", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.TryResolve``1(Microsoft.Extensions.DependencyInjection.IServiceScope)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.TryResolve(Microsoft.Extensions.DependencyInjection.IServiceScope,System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.Resolve``1(Microsoft.Extensions.DependencyInjection.IServiceScope)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.Resolve(Microsoft.Extensions.DependencyInjection.IServiceScope,System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.TryResolve``1(Microsoft.Extensions.DependencyInjection.IServiceScope,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.TryResolve(Microsoft.Extensions.DependencyInjection.IServiceScope,System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.Resolve``1(Microsoft.Extensions.DependencyInjection.IServiceScope,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.Resolve(Microsoft.Extensions.DependencyInjection.IServiceScope,System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.<M>$5FFAFCDCD6BF0176379AA44C5912BDE9", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"scope", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.TryResolve``1", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.TryResolve(System.Type)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.Resolve``1", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.Resolve(System.Type)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.TryResolve``1(System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"key name", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.TryResolve(System.Type,System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"key name", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.Resolve``1(System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"key name", null, false)], null));
            cache.Add(@"M:FastEndpoints.ServiceScopeExtensions.<G>$8B1E0B065ADD9CA16E85EC382B5A5354.Resolve(System.Type,System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"key name", null, false)], null));

            cache.Add(@"T:FastEndpoints.UserPrivileges", new XmlComment(@"the priviledges of the user which will be embedded in the jwt or cookie", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.UserPrivileges.Claims", new XmlComment(@"claims of the user", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.UserPrivileges.Roles", new XmlComment(@"roles of the user", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.UserPrivileges.Permissions", new XmlComment(@"allowed permissions for the user", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.UserPrivileges.Item(System.String)", new XmlComment(@"shortcut for adding a new Claim to the claim list for the given claim type and value", null, null, null, null, false, null, [new XmlParameterComment(@"claimType", @"the claim type to add", null, false)], null));
            cache.Add(@"T:FastEndpoints.BinderContext", new XmlComment(@"binder context supplied to custom request binders.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.HttpContext", new XmlComment(@"the http context of the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.ValidationFailures", new XmlComment(@"a list of validation failures for the endpoint. you can add your own validation failures for properties of the request dto using this property.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.SerializerOptions", new XmlComment(@"the configured json serializer options of the app, which was specified at app startup.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.JsonSerializerContext", new XmlComment(@"if the current endpoint is configured with a json serializer context, it will be provided to the custom request binder with this property.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.DontAutoBindForms", new XmlComment(@"set 'true' to disable auto binding of form data which enables uploading and reading of large files without buffering to memory/disk.
you can access the multipart sections for reading via the FormFileSectionsAsync() method.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BinderContext.UnboundRequiredProperties", new XmlComment(@"indicates which required properties were not bound due to missing input from the request.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.#ctor(Microsoft.AspNetCore.Http.HttpContext,System.Collections.Generic.List{FluentValidation.Results.ValidationFailure},System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Collections.Generic.IEnumerable{System.String})", new XmlComment(@"constructor of the binder context", null, null, null, null, false, null, [new XmlParameterComment(@"httpContext", @"the http context of the current request", null, false), new XmlParameterComment(@"validationFailures", @"the validation failure collection of the endpoint", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context of the endpoint if applicable", null, false), new XmlParameterComment(@"dontAutoBindForms", @"whether to enable auto binding of form data", null, false), new XmlParameterComment(@"bindRequiredProps", @"collection of required property names", null, false)], null));
            cache.Add(@"M:FastEndpoints.BinderContext.TryResolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.TryResolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.Resolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.Resolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.CreateScope", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.TryResolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.TryResolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.Resolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BinderContext.Resolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.BindingSource", new XmlComment(@"enum for choosing which binding sources the default request binder should use", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IRequestBinder`1", new XmlComment(@"create custom request binders by implementing this interface. by registering a custom modelbinder for an endpoint will completely disable the
built-in model binding and completely depend on your implementation of the custom binder to return a correctly populated request dto for the
endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IRequestBinder`1.BindAsync(FastEndpoints.BinderContext,System.Threading.CancellationToken)", new XmlComment(@"this method will be called by the library for binding the incoming request data and return a populated request dto object.
access the incoming request data via the `RequestBinderContext` and populate a new request dto instance and return it from this method.", null, null, null, null, false, null, [new XmlParameterComment(@"ctx", @"request binder context encapsulating the incoming http request context, a list of validation failures for the endpoint, and an
optional json serializer context.", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.RequestBinder`1", new XmlComment(@"the default request binder for a given request dto type", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RequestBinder`1.#ctor", new XmlComment(@"default constructor which enables all binding sources", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RequestBinder`1.#ctor(FastEndpoints.BindingSource)", new XmlComment(@"constructor accepting a bitwise combination of enums which enables only the specified binding sources", null, null, null, null, false, null, [new XmlParameterComment(@"enabledSources", @"a bitwise combination of enum values", null, false)], null));
            cache.Add(@"M:FastEndpoints.RequestBinder`1.BindAsync(FastEndpoints.BinderContext,System.Threading.CancellationToken)", new XmlComment(@"override this method to customize the request binding logic", null, null, null, null, false, null, [new XmlParameterComment(@"ctx", @"the request binder context which holds all the data required for binding the incoming request", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.BindingOptions", new XmlComment(@"request binding options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.UsePropertyNamingPolicy", new XmlComment(@"specify whether to use the json property naming policy when matching incoming field names to dto property names for non-json model binding.
only applies when field names are not specified on properties with attributes such as [BindFrom(...)], [FromClaim(...)], [FromHeader(...)] etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.UseDefaultValuesForNullableProps", new XmlComment(@"by default, if a dto property is nullable and an incoming parameter value is omitted while only the parameter name exists, the default value for the property
will be populated. setting `false` will prevent that from happening. only applies to non-STJ binding paths such as when binding from
route/query/claims/headers/form fields etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.ReflectionCache", new XmlComment(@"the central cache of request dto related reflection data.
populating this cache with source generated data will eliminate expression compilations during runtime as well as usage of
reflection based property setters, etc. see the source generator documentation on how to populate this cache with generated data.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.FailureMessage", new XmlComment(@"            a function used to construct the failure message when a supplied value cannot be successfully bound to a dto property during model binding.
            NOTE: this only applies to non-STJ operations. for customizing error messages of STJ binding failures, specify a
Func&lt;JsonException, ValidationFailure&gt;? BindingOptions.JsonExceptionTransformer func.
            the following arguments are supplied to the function.
            Type: the type of the property which failed to bindstring: the name of the property which failed to bindStringValues: the value that was attempted which resulted in the failure
            use these input parameters and construct your own error message string and return it from the function.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.JsonExceptionTransformer", new XmlComment(@"            by default, all STJ JsonExceptions thrown during deserialization are automatically caught and transformed using this function.
            if you'd like to disable this behavior, simply set this property to `null` or specify a function to construct a
            ValidationFailure when STJ throws an exception due to invalid json input.
            NOTE: this only applies to STJ based operations. for customizing error messages of non-STJ binding failures, specify a
Func&lt;Type, string, StringValues, string&gt; BindingOptions.FailureMessage func.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.JsonExceptionStatusCode", new XmlComment(@"this http status code will be used for all automatically sent JsonException responses  which are built using the
Func&lt;JsonException, ValidationFailure&gt;? BindingOptions.JsonExceptionTransformer
func. defaults to 400.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.FormExceptionTransformer", new XmlComment(@"if this function is specified, any internal exceptions that are thrown by asp.net when accessing multipart form data will be caught and transformed to
validation
failures using this function. by default those exceptions are not caught and thrown out to the middleware pipeline. setting this func might come in handy
if
you need 413 responses (that arise from incoming request body size exceeding kestrel's `MaxRequestBodySize`) automatically transformed to 400 problem
details
responses.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.BindingOptions.Modifier", new XmlComment(@"an optional action to be run after the endpoint level request binding has occured.
it is intended as a way to perform common model binding logic that applies to all endpoints/requests.
the action is passed in the following arguments:
object: the request dto instanceType: the type of the request dtoBinderContext: the request binding contextCancellationToken: a cancellation tokenWARNING: be mindful of the performance cost of using reflection to modify the request dto object", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BindingOptions.ValueParserFor``1(System.Func{Microsoft.Extensions.Primitives.StringValues,FastEndpoints.ParseResult})", new XmlComment(@"add a custom value parser function for any given type which the default model binder will use to parse values when model binding request dto
properties from query/route/forms/headers/claims.
this is an alternative approach to adding a `TryParse()` function to your types that need model binding support from the abovementioned binding
sources.
once you register a parser function here for a type, any `TryParse()` method on the type will not be used for parsing.
also, these parser functions do not apply to JSON deserialization done by STJ and can be considered the equivalent to registering a custom converter
in STJ when it comes to query/route/forms/headers/claims binding sources.", null, null, null, null, false, null, [new XmlParameterComment(@"parser", @"             a function that takes in a nullable object and returns a ParseResult as the output.
             ```app.UseFastEndpoints(c =&gt;
{
    c.Binding.ValueParserFor&lt;Guid&gt;(MyParsers.GuidParser);
});

public static class MyParsers
{
    public static ParseResult GuidParser(object? input)
    {
        Guid result;
        bool success = Guid.TryParse(input?.ToString(), out result);
        return new(success, result);
    }
}```", null, false)], null));
            cache.Add(@"M:FastEndpoints.BindingOptions.ValueParserFor(System.Type,System.Func{Microsoft.Extensions.Primitives.StringValues,FastEndpoints.ParseResult})", new XmlComment(@"add a custom value parser function for any given type which the default model binder will use to parse values when model binding request dto
properties from query/route/forms/headers/claims.
this is an alternative approach to adding a `TryParse()` function to your types that need model binding support from the abovementioned binding
sources.
once you register a parser function here for a type, any `TryParse()` method on the type will not be used for parsing.
also, these parser functions do not apply to JSON deserialization done by STJ and can be considered the equivalent to registering a custom converter
in STJ when it comes to query/route/forms/headers/claims binding sources.", null, null, null, null, false, null, [new XmlParameterComment(@"type", @"the type of the class which this parser function will target", null, false), new XmlParameterComment(@"parser", @"             a function that takes in a nullable object and returns a ParseResult as the output.
             ```app.UseFastEndpoints(c =&gt;
{
    c.Binding.ValueParserFor(typeof(Guid), MyParsers.GuidParser);
});

public static class MyParsers
{
    public static ParseResult GuidParser(object? input)
    {
        Guid result;
        bool success = Guid.TryParse(input?.ToString(), out result);
        return new(success, result);
    }
}```", null, false)], null));
            cache.Add(@"M:FastEndpoints.BindingOptions.ValueParserWhen(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{System.Object,System.Type,FastEndpoints.ParseResult})", new XmlComment(@"override value parsers for request dto properties that match a predicate.
WARNING: might lead to weird/untraceable behavior. use at own risk!", null, null, null, null, false, null, [new XmlParameterComment(@"propertyMatcher", @"a predicate for qualifying a property", null, false), new XmlParameterComment(@"parser", @"the value parser for the matched property type", null, false)], null));
            cache.Add(@"T:FastEndpoints.Config", new XmlComment(@"global configuration settings for FastEndpoints", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Binding", new XmlComment(@"request binding settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Endpoints", new XmlComment(@"endpoint discovery &amp; registration settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Errors", new XmlComment(@"error response customization settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Security", new XmlComment(@"security related settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Serializer", new XmlComment(@"settings for customizing serialization behavior", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Throttle", new XmlComment(@"endpoint throttling/ rate limiting settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Versioning", new XmlComment(@"endpoint versioning settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Config.Validation", new XmlComment(@"endpoint validation settings", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointOptions", new XmlComment(@"endpoint registration options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.NameGenerator", new XmlComment(@"specify a function to customize the endpoint name/swagger operation id. generate an endpoint name however you wish and return a string
from your function. all available info for name generation is supplied via the EndpointNameGenerationContext.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.ShortNames", new XmlComment(@"set to true if you'd like the endpoint names/ swagger operation ids to be just the endpoint class names instead of the full names including
namespace.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.PrefixNameWithFirstTag", new XmlComment(@"set to true if you'd like to automatically prefix endpoint name (swagger operation id) with the first endpoint tag.
the generated the operation id would be in the form of: `MyTag_CreateOrderEndpoint`.  this should come in handy with generating separate api clients
with nswag using the ""MultipleClientsFromOperationId"" setting  which requires operation ids to be have a group name prefix with an underscore.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.RoutePrefix", new XmlComment(@"prefix for all routes (example 'api').", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.Filter", new XmlComment(@"a function to filter out endpoints from auto registration.
the function you set here will be executed for each endpoint during startup.
you can inspect the EndpointSettings to check what the current endpoint is, if needed.
return 'false' from the function if you want to exclude an endpoint from registration.
return 'true' to include.
this function will execute for each endpoint that has been discovered during startup.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.Configurator", new XmlComment(@"            a configuration action to be performed on each endpoint definition during startup.
            some of the same methods you use inside `Configure()` method are available to be called on the `EndpointDefinition` parameter.
            this can be used to apply a set of common configuration settings globally to all endpoints.
            i.e. apply globally applicable settings here and specify only the settings applicable to individual endpoints from within each endpoints'
            `Configure()` method.
            ```app.UseFastEndpoints(c =&gt; c.Configurator = ep =&gt;
{
    ep.AllowAnonymous();
    ep.Description(b =&gt; b.Produces&lt;ErrorResponse&gt;(400));
});```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.AllowEmptyRequestDtos", new XmlComment(@"allows the use of empty request dtos", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.GlobalResponseModifier", new XmlComment(@"            a global response modifier which will be executed right before any response is written to the response stream, giving you a chance to modify the
            response before being sent.
            the arguments for the func are:
            ```HttpContext : the http context of the current request/response
object? : response content which may be null```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointOptions.GlobalResponseModifierAsync", new XmlComment(@"            an async global response modifier function which will be executed right before any response is written to the response stream, giving you a chance to
            modify the response before being sent.
            the arguments for the func are:
            ```HttpContext : the http context of the current request/response
object? : response content which may be null```", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ErrorOptions", new XmlComment(@"error response customization settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.StatusCode", new XmlComment(@"this http status code will be used for all automatically sent validation failure responses. defaults to 400.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ContentType", new XmlComment(@"the content-type header value for 400 error responses", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProducesMetadataType", new XmlComment(@"            if this property is not null, a IProducesResponseTypeMetadata will automatically be added to endpoints that has a
            Validator&lt;TRequest&gt; associated with it.
            if you're specifying your own Func&lt;List&lt;ValidationFailure&gt;, HttpContext, int, object&gt; ErrorOptions.ResponseBuilder, don't forget to set this property to the correct type of the error response dto that
            your error response builder will be returning.
            TIP: set this to null if you'd like to disable the auto adding of produces 400 metadata to endpoints even if they have validators associated with
them.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.GeneralErrorsField", new XmlComment(@"the general errors field name. this is the field name used for general errors when AddError() method is called without specifying a request dto
property.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ResponseBuilder", new XmlComment(@"a function for transforming validation errors to an error response dto.
set it to any func that returns an object that can be serialized to json.
this function will be run everytime an error response needs to be sent to the client.
the arguments for the func will be a list of validation failures, the http context and a http status code.
HINT: if changing the default, make sure to also set Type? ErrorOptions.ProducesMetadataType to the correct type of the error response dto.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ErrorOptions.UseProblemDetails(System.Action{FastEndpoints.ErrorOptions.ProblemDetailsConfig})", new XmlComment(@"change the default error response builder to ProblemDetails instead of ErrorResponse", null, null, null, null, false, null, [new XmlParameterComment(@"config", @"an action for configuring global settings for ProblemDetails", null, false)], null));
            cache.Add(@"T:FastEndpoints.ErrorOptions.ProblemDetailsConfig", new XmlComment(@"global settings for ProblemDetails error responses.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.ResponseBuilder", new XmlComment(@"sets a function used for transforming validation errors to a RFC7807 compatible problem details error response dto.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.Map", new XmlComment(@"the built-in map that ties together status codes to the relevant title and type values.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.TitleValue", new XmlComment(@"globally sets the value of string ProblemDetails.Title.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.TitleTransformer", new XmlComment(@"sets a function that will be called per instance/response that allows customization of the string ProblemDetails.Title value.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.TypeValue", new XmlComment(@"globally sets the value of string ProblemDetails.Type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.TypeTransformer", new XmlComment(@"sets a function that will be called per instance/response that allows customization of the string ProblemDetails.Type value.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.DetailTransformer", new XmlComment(@"sets a function that will be called per instance/response that allows customization of the string? ProblemDetails.Detail value.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.AllowDuplicateErrors", new XmlComment(@"controls whether duplicate errors with the same name should be allowed for IEnumerable&lt;Error&gt; ProblemDetails.Errors.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.IndicateErrorCode", new XmlComment(@"if set to true, the string ValidationFailure.ErrorCode value of the failure will be serialized to the response.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorOptions.ProblemDetailsConfig.IndicateErrorSeverity", new XmlComment(@"if set to true, the Severity value of the failure will be serialized to the response.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.SecurityOptions", new XmlComment(@"global security options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SecurityOptions.NameClaimType", new XmlComment(@"specify a custom claim type used to identity the name of a user principal. defaults to `name`.
WARNING: do not change the default unless you fully comprehend what you're doing!!!", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SecurityOptions.PermissionsClaimType", new XmlComment(@"specify a custom claim type used to identify permissions of a user principal. defaults to `permissions`.
WARNING: do not change the default unless you fully comprehend what you're doing!!!", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SecurityOptions.ScopeClaimType", new XmlComment(@"specify a custom claim type used to identify scopes. defaults to `scope`.
WARNING: do not change the default unless you fully comprehend what you're doing!!!", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SecurityOptions.ScopeParser", new XmlComment(@"a function for parsing the 'scope' claim value and producing a collection of scopes.
the default function simply splits the input string using the space character.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SecurityOptions.RoleClaimType", new XmlComment(@"specify a custom claim type used to identify roles of a user principal. defaults to `role`.
WARNING: do not change the default unless you fully comprehend what you're doing!!!", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.SerializerOptions", new XmlComment(@"serialization options for the endpoints", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SerializerOptions.Options", new XmlComment(@"the json serializer options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SerializerOptions.SerializerErrorsField", new XmlComment(@"this is the field name used for adding serializer errors when the serializer throws due to bad json input and the error is not concerning a
particular property/field of the incoming json.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SerializerOptions.CharacterEncoding", new XmlComment(@"the charset used for responses. this will be appended to the content-type header when the Func&lt;HttpResponse, object?, string, JsonSerializerContext?, CancellationToken, Task&gt; SerializerOptions.ResponseSerializer func is used.
defaults to `utf-8`. set to `null` to disable appending a charset.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SerializerOptions.RequestDeserializer", new XmlComment(@"            a function for deserializing the incoming http request body. this function will be executed for each request received if it has a json request body.
            the input parameters of the func are as follows:
            ```HttpRequest : the incoming request
Type : the type of the request dto which the request body will be deserialized into
JsonSerializerContext? : json serializer context if code generation is used
CancellationToken : a cancellation token```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SerializerOptions.ResponseSerializer", new XmlComment(@"            a function for writing serialized response dtos to the response body.
            this function will be executed whenever a json response is being sent to the client.
            you should set the content-type and write directly to the http response body stream in this function.
            the parameters of the func are as follows:
            ```HttpResponse : the http response object.
object : the response dto to be serialized.
string : the response content-type.
JsonSerializerContext? : json serializer context if code generation is used.
CancellationToken : a cancellation token.```example:```config.ResponseSerializer = (rsp, dto, cType, jCtx , ct) =&gt;
{
    rsp.ContentType = cType;
    return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct);
};```", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ThrottleOptions", new XmlComment(@"global settings for throttling", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ThrottleOptions.HeaderName", new XmlComment(@"header used to track rate limits", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ThrottleOptions.Message", new XmlComment(@"custom error response message for throttled requests", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ValidationOptions", new XmlComment(@"validation related options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationOptions.EnableDataAnnotationsSupport", new XmlComment(@"set this property to `true` if you'd like to enable support for `System.ComponentModel.DataAnnotations` attributes for basic validation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationOptions.UsePropertyNamingPolicy", new XmlComment(@"specify whether to use the json property naming policy of the application for converting property names produced by fluentvalidations library", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.VersioningOptions", new XmlComment(@"global endpoint versioning options", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.VersioningOptions.Prefix", new XmlComment(@"the prefix used in front of the version (for example 'v' produces 'v{version}').", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.VersioningOptions.RouteTemplate", new XmlComment(@"if a route template is specified here, the template string in endpoint routes will be replaced by the version of the endpoint.
this setting will render bool? VersioningOptions.PrependToRoute ineffective if also set.
setting a value here makes it mandatory to specify the template in all routes of versioned endpoints.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.VersioningOptions.DefaultVersion", new XmlComment(@"this value will be used on endpoints that does not specify a version", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.VersioningOptions.PrependToRoute", new XmlComment(@"set to true if you'd like to prefix the version to the route instead of being suffixed which is the default.
if string? VersioningOptions.RouteTemplate is specified, that will take precedence over this setting.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EmptyRequest", new XmlComment(@"a request dto that doesn't have any properties.
Note: This is a class (not struct) for Native AOT compatibility.
Value types don't work with generic services in Native AOT.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EmptyRequest._dummy", new XmlComment(@"Dummy property required by FastEndpoints request binder (DTOs must have at least one property)", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EmptyResponse", new XmlComment(@"a response dto that doesn't have any properties.
Note: This is a class (not struct) for Native AOT compatibility.
Value types used as generic type arguments can cause issues in Native AOT.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EmptyResponse._dummy", new XmlComment(@"Dummy property for serialization compatibility", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ErrorResponse", new XmlComment(@"the dto used to send an error response to the client", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorResponse.StatusCode", new XmlComment(@"the http status code sent to the client. default is 400.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorResponse.Message", new XmlComment(@"the message for the error response", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ErrorResponse.Errors", new XmlComment(@"the collection of errors for the current context", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ErrorResponse.#ctor", new XmlComment(@"instantiate a new error response without any errors", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ErrorResponse.#ctor(System.Collections.Generic.List{FluentValidation.Results.ValidationFailure},System.Int32)", new XmlComment(@"instantiate an error response with the given collection validation failures", null, null, null, null, false, null, [new XmlParameterComment(@"failures", @"validation failures to initialize the DTO with", null, false)], null));
            cache.Add(@"M:FastEndpoints.ErrorResponse.PopulateMetadata(System.Reflection.MethodInfo,Microsoft.AspNetCore.Builder.EndpointBuilder)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.MultipartSection", new XmlComment(@"represents a multipart form section which could contain either a FormMultipartSection or a FileMultipartSection.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, [new XmlParameterComment(@"form", @"", null, false), new XmlParameterComment(@"file", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.MultipartSection.#ctor(Microsoft.AspNetCore.WebUtilities.FormMultipartSection,Microsoft.AspNetCore.WebUtilities.FileMultipartSection)", new XmlComment(@"represents a multipart form section which could contain either a FormMultipartSection or a FileMultipartSection.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, [new XmlParameterComment(@"form", @"", null, false), new XmlParameterComment(@"file", @"", null, false)], null));
            cache.Add(@"T:FastEndpoints.InternalErrorResponse", new XmlComment(@"the dto used to send an error response to the client when an unhandled exception occurs on the server", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.InternalErrorResponse.Status", new XmlComment(@"error status", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.InternalErrorResponse.Code", new XmlComment(@"http status code of the error response", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.InternalErrorResponse.Reason", new XmlComment(@"the reason for the error", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.InternalErrorResponse.Note", new XmlComment(@"additional information or instructions", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPlainTextRequest", new XmlComment(@"implement this interface on your request dto if you need to model bind the raw content body of an incoming http request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPlainTextRequest.Content", new XmlComment(@"the request body content will be bound to this property", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PlainTextRequest", new XmlComment(@"use this dto if you need to model bind the raw content body of an incoming http request or you may implement the IPlainTextRequest interface on your own request dto.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PlainTextRequest.Content", new XmlComment(@"the body content of the incoming request", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ProblemDetails", new XmlComment(@"RFC7807 compatible problem details/ error response class. this can be used by configuring startup like so:
```app.UseFastEndpoints(c =&gt; c.Errors.UseProblemDetails())```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ProblemDetails.Detail", new XmlComment(@"the details of the error", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ProblemDetails.ExecuteAsync(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ProblemDetails.PopulateMetadata(System.Reflection.MethodInfo,Microsoft.AspNetCore.Builder.EndpointBuilder)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ProblemDetails.Error", new XmlComment(@"the error details object", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ProblemDetails.Error.Name", new XmlComment(@"the name of the error or property of the dto that caused the error", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ProblemDetails.Error.Reason", new XmlComment(@"the reason for the error", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ProblemDetails.Error.Code", new XmlComment(@"the code of the error", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ProblemDetails.Error.Severity", new XmlComment(@"the severity of the error", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StreamItem.Id", new XmlComment(@"event id", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StreamItem.EventName", new XmlComment(@"event name", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StreamItem.Data", new XmlComment(@"event data", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StreamItem.Retry", new XmlComment(@"reconnection time in milliseconds", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.StreamItem.#ctor(System.String,System.Object)", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"eventName", @"the name of the event", null, false), new XmlParameterComment(@"data", @"the event data", null, false)], null));
            cache.Add(@"M:FastEndpoints.StreamItem.#ctor(System.String,System.String,System.Object,System.Nullable{System.Int32})", new XmlComment(@"", null, null, null, null, false, null, [new XmlParameterComment(@"id", @"the id of the event", null, false), new XmlParameterComment(@"eventName", @"the name of the event", null, false), new XmlParameterComment(@"data", @"the event data", null, false), new XmlParameterComment(@"retry", @"reconnection time in milliseconds", null, false)], null));
            cache.Add(@"M:FastEndpoints.StreamItem.GetDataString(System.Text.Json.JsonSerializerOptions)", new XmlComment(@"override this method in order to take control of the serialization of the event data", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"json serializer options", null, false)], null));
            cache.Add(@"T:FastEndpoints.EndpointDefinition", new XmlComment(@"represents the configuration settings of an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.#ctor(System.Type,System.Type,System.Type)", new XmlComment(@"represents the configuration settings of an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AllowAnonymous(FastEndpoints.Http[])", new XmlComment(@"allow unauthenticated requests to this endpoint. optionally specify a set of verbs to allow unauthenticated access with.
i.e. if the endpoint is listening to POST, PUT &amp; PATCH and you specify AllowAnonymous(Http.POST), then only PUT &amp; PATCH will require
authentication.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AllowAnonymous(System.String[])", new XmlComment(@"allow unauthenticated requests to this endpoint for a specified set of http verbs.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AllowFileUploads(System.Boolean)", new XmlComment(@"enable file uploads with multipart/form-data content type", null, null, null, null, false, null, [new XmlParameterComment(@"dontAutoBindFormData", @"set 'true' to disable auto binding of form data which enables uploading and reading of large files without buffering to memory/disk.
you can access the multipart sections for reading via the IAsyncEnumerable&lt;FileMultipartSection?&gt; Endpoint&lt;TRequest, TResponse&gt;.FormFileSectionsAsync(CancellationToken cancellation = default(CancellationToken)) method.", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AllowFormData(System.Boolean)", new XmlComment(@"enable form-data submissions", null, null, null, null, false, null, [new XmlParameterComment(@"urlEncoded", @"set to true to accept `application/x-www-form-urlencoded` content instead of `multipart/form-data` content.", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AuthSchemes(System.String[])", new XmlComment(@"specify which authentication schemes to use for authenticating requests to this endpoint
HINT: these auth schemes will be applied in addition to endpoint level auth schemes if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"authSchemeNames", @"the authentication scheme names", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AdditionalVerbs(FastEndpoints.Http[])", new XmlComment(@"specify extra http verbs in addition to the endpoint level verbs.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.AdditionalVerbs(System.String[])", new XmlComment(@"specify extra http verbs in addition to the endpoint level verbs.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Claims(System.String[])", new XmlComment(@"allows access if the claims principal has ANY of the given claim types
HINT: these claims will be applied in addition to endpoint level claims if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"claimTypes", @"the claim types", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.ClaimsAll(System.String[])", new XmlComment(@"allows access if the claims principal has ALL the given claim types
HINT: these claims will be applied in addition to endpoint level claims if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"claimTypes", @"the claim types", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Description(System.Action{Microsoft.AspNetCore.Builder.RouteHandlerBuilder},System.Boolean)", new XmlComment(@"describe openapi metadata for this endpoint. optionally specify whether you want to clear the default Accepts/Produces metadata.
EXAMPLE: b =&gt; b.Accepts&lt;Request&gt;(""text/plain"")", null, null, null, null, false, null, [new XmlParameterComment(@"builder", @"the route handler builder for this endpoint", null, false), new XmlParameterComment(@"clearDefaults", @"set to true if the defaults should be cleared", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.DontAutoSendResponse", new XmlComment(@"disables auto sending of responses when the endpoint handler doesn't explicitly send a response. most useful for allowing a post-processor to
handle sending of the response.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.DontAutoTag", new XmlComment(@"if swagger auto tagging based on path segment is enabled, calling this method will prevent a tag from being added to this endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.DontCatchExceptions", new XmlComment(@"use this only if you have your own exception catching middleware.
if this method is called in config, an automatic error response will not be sent to the client by the library.
all exceptions will be thrown, and it would be your exception catching middleware to handle them.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.DontThrowIfValidationFails", new XmlComment(@"disable auto validation failure responses (400 bad request with error details) for this endpoint.
HINT: this only applies to request dto validation.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.EnableAntiforgery", new XmlComment(@"enable antiforgery token verification for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.EndpointVersion(System.Int32,System.Int32)", new XmlComment(@"specify the version of this endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"version", @"the version of this endpoint", null, false), new XmlParameterComment(@"deprecateAt", @"the version number starting at which this endpoint should not be included in swagger document", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.FeatureFlag``1(System.String)", new XmlComment(@"specify a feature flag to run in order to determine if this endpoint is enabled or disabled for the current request.", null, null, null, null, false, null, [new XmlParameterComment(@"featureName", @"optional name of the feature flag", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Group``1", new XmlComment(@"if this endpoint is part of an endpoint group, specify the type of the Group concrete class where the common
configuration for the group is specified.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Idempotency(System.Action{FastEndpoints.IdempotencyOptions})", new XmlComment(@"specify idempotency requirements for this endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"the idempotency options", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.MaxRequestBodySize(System.Int64)", new XmlComment(@"specify a custom maximum request body size to be set on long? IHttpMaxRequestBodySizeFeature.MaxRequestBodySize which would apply to this particular
endpoint only. typically useful with void EndpointDefinition.AllowFormData(bool urlEncoded = false) and void EndpointDefinition.AllowFileUploads(bool dontAutoBindFormData = false).", null, null, null, null, false, null, [new XmlParameterComment(@"size", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Options(System.Action{Microsoft.AspNetCore.Builder.RouteHandlerBuilder})", new XmlComment(@"set endpoint configurations options using an endpoint builder action", null, null, null, null, false, null, [new XmlParameterComment(@"builder", @"the builder for this endpoint", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Permissions(System.String[])", new XmlComment(@"allows access if the claims principal has ANY of the given permissions
HINT: these permissions will be applied in addition to endpoint level permissions if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"permissions", @"the permissions", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PermissionsAll(System.String[])", new XmlComment(@"allows access if the claims principal has ALL the given permissions
HINT: these permissions will be applied in addition to endpoint level permissions if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"permissions", @"the permissions", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Scopes(System.String[])", new XmlComment(@"allows access if the 'scope' claim has ANY of the given scopes.
HINT: these scopes will be applied in addition to endpoint level scopes if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"scopes", @"the permissions", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.ScopesAll(System.String[])", new XmlComment(@"allows access if the 'scope' claim has ALL the given scopes.
HINT: these scopes will be applied in addition to endpoint level scopes if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"scopes", @"the permissions", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Policy(System.Action{Microsoft.AspNetCore.Authorization.AuthorizationPolicyBuilder})", new XmlComment(@"specify an action for building an authorization requirement which should be added to all endpoints globally.
HINT: these global level requirements will be combined with the requirements specified at the endpoint level if there's any.", null, null, null, null, false, null, [new XmlParameterComment(@"policy", @"th policy builder action", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Policies(System.String[])", new XmlComment(@"specify one or more authorization policy names you have added to the middleware pipeline during app startup/ service configuration that should be
applied to this endpoint.
HINT: these policies will be applied in addition to endpoint level policies if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"policyNames", @"one or more policy names (must have been added to the pipeline on startup)", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PostProcessors(FastEndpoints.Order,FastEndpoints.IGlobalPostProcessor[])", new XmlComment(@"adds global post-processors to an endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global post-processors should be executed before endpoint post-processors.
Order.After will execute global processors after endpoint level processors", null, false), new XmlParameterComment(@"postProcessors", @"the post-processors to add", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PostProcessor``1(FastEndpoints.Order)", new XmlComment(@"adds global post-processor to an endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global post-processors should be executed before endpoint post-processors.
Order.After will execute global processors after endpoint level processors", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PostProcessors(FastEndpoints.Order,System.Type[])", new XmlComment(@"adds open-generic post-processors to the endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global post-processors should be executed before endpoint post-processors.
Order.After will execute global processors after endpoint level processors", null, false), new XmlParameterComment(@"processorTypes", @"open generic post-processor types", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PreProcessors(FastEndpoints.Order,FastEndpoints.IGlobalPreProcessor[])", new XmlComment(@"adds global pre-processors to an endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global pre-processors should be executed before endpoint pre-processors.
Order.After will execute global processors after endpoint level processors", null, false), new XmlParameterComment(@"preProcessors", @"the pre-processors to add", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PreProcessor``1(FastEndpoints.Order)", new XmlComment(@"adds global pre-processor to an endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global pre-processors should be executed before endpoint pre-processors.
Order.After will execute global processors after endpoint level processors", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.PreProcessors(FastEndpoints.Order,System.Type[])", new XmlComment(@"adds open-generic pre-processors to the endpoint definition which are to be executed in addition to the ones configured at the endpoint level.", null, null, null, null, false, null, [new XmlParameterComment(@"order", @"set to Order.Before if the global pre-processors should be executed before endpoint pre-processors.
Order.After will execute global processors after endpoint level processors", null, false), new XmlParameterComment(@"processorTypes", @"open generic pre-processor types", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.RequestBinder(System.Type)", new XmlComment(@"sets an open-generic request binder for the endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"binderType", @"the open generic type of the request binder", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.ResponseCache(System.Int32,Microsoft.AspNetCore.Mvc.ResponseCacheLocation,System.Boolean,System.String,System.String[])", new XmlComment(@"specify response caching settings for this endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"durationSeconds", @"the duration in seconds for which the response is cached", null, false), new XmlParameterComment(@"location", @"the location where the data from a particular URL must be cached", null, false), new XmlParameterComment(@"noStore", @"specify whether the data should be stored or not", null, false), new XmlParameterComment(@"varyByHeader", @"the value for the Vary response header", null, false), new XmlParameterComment(@"varyByQueryKeys", @"the query keys to vary by", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.ResponseInterceptor(FastEndpoints.IResponseInterceptor)", new XmlComment(@"configure a response interceptor to be called before any SendAsync() methods are called.
if the interceptor sends a response to the client, the SendAsync() will be ignored.", null, null, null, null, false, null, [new XmlParameterComment(@"responseInterceptor", @"the response interceptor to be configured for the endpoint", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Roles(System.String[])", new XmlComment(@"allows access if the claims principal has ANY of the given roles
HINT: these roles will be applied in addition to endpoint level roles if there's any", null, null, null, null, false, null, [new XmlParameterComment(@"rolesNames", @"one or more roles that has access", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.RoutePrefixOverride(System.String)", new XmlComment(@"            specify an override route prefix for this endpoint if a global route prefix is enabled.
            this is ignored if a global route prefix is not configured.
            global prefix can be ignored by setting `string.Empty`WARNING: setting a route prefix override globally makes the endpoint level override ineffective. i.e. RoutePrefixOverride() method call on
endpoint level will be ignored.", null, null, null, null, false, null, [new XmlParameterComment(@"routePrefix", @"route prefix value", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Summary(System.Action{FastEndpoints.EndpointSummary})", new XmlComment(@"provide a summary/description for this endpoint to be used in swagger/ openapi", null, null, null, null, false, null, [new XmlParameterComment(@"endpointSummary", @"an action that sets values of an endpoint summary object", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Summary``1(System.Action{FastEndpoints.EndpointSummary{``0}})", new XmlComment(@"provide a summary/description for this endpoint to be used in swagger/ openapi", null, null, null, null, false, null, [new XmlParameterComment(@"endpointSummary", @"an action that sets values of an endpoint summary object", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Summary(FastEndpoints.EndpointSummary)", new XmlComment(@"provide a summary/description for this endpoint to be used in swagger/ openapi", null, null, null, null, false, null, [new XmlParameterComment(@"endpointSummary", @"an endpoint summary instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Tags(System.String[])", new XmlComment(@"specify one or more string tags for this endpoint so they can be used in the exclusion filter during registration.
HINT: these tags will be applied in addition to endpoint level tags if there's anyTIP: these tags have nothing to do with swagger tags!", null, null, null, null, false, null, [new XmlParameterComment(@"endpointTags", @"the tag values to associate with this endpoint", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Throttle(System.Int32,System.Double,System.String)", new XmlComment(@"rate limit requests to this endpoint based on a request http header sent by the client.", null, null, null, null, false, null, [new XmlParameterComment(@"hitLimit", @"how many requests are allowed within the given duration", null, false), new XmlParameterComment(@"durationSeconds", @"the frequency in seconds where the accrued hit count should be reset", null, false), new XmlParameterComment(@"headerName", @"the name of the request header used to uniquely identify clients.
header name can also be configured globally using `app.UseFastEndpoints(c=&gt; c.Throttle...)`
not specifying a header name will first look for 'X-Forwarded-For' header and if not present, will use `HttpContext.Connection.RemoteIpAddress`.", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointDefinition.Validator``1", new XmlComment(@"validator that should be used for this endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EpVersion", new XmlComment(@"represents an endpoint version", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EpVersion.StartingRelease(System.Int32)", new XmlComment(@"     specify the ""release"" number of the swagger document where this endpoint should start showing up in.
     for example, if a swagger doc such as the following is defined:
     ```bld.Services.SwaggerDocument(
o =&gt;
{
    o.DocumentSettings = d =&gt; d.DocumentName = ""Release 2"";
    o.ReleaseVersion = 2;
})```
     this endpoint will only show up for the above doc and later if you do the following:
     ```Version(n).StartingRelease(2);```", null, null, null, null, false, null, [new XmlParameterComment(@"version", @"the starting release version number of the swagger doc", null, false)], null));
            cache.Add(@"M:FastEndpoints.EpVersion.DeprecateAt(System.Int32)", new XmlComment(@"            specify starting at which version this endpoint should be considered deprecated.
            NOTE: it would be the endpoint version to deprecate at for ""release group"" strategy, and the ""release version"" of the swagger doc when using the
""release version"" strategy.", null, null, null, null, false, null, [new XmlParameterComment(@"version", @"", null, false)], null));
            cache.Add(@"T:FastEndpoints.Group", new XmlComment(@"common configuration for a group of endpoints can be specified by implementing this abstract class and calling
void Group.Configure(string routePrefix, Action&lt;EndpointDefinition&gt; ep) in the constructor.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.TryResolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.TryResolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.Resolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.Resolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.CreateScope", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.TryResolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.TryResolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.Resolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Group.Resolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.SubGroup`1", new XmlComment(@"common configuration for a sub group of endpoints can be specified by implementing this abstract class and calling
void SubGroup&lt;TParent&gt;.Configure(string routePrefix, Action&lt;EndpointDefinition&gt; ep) in the constructor.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.GroupAttribute`1", new XmlComment(@"generic attribute for designating a group that an endpoint belongs. only effective when attribute based endpoint configuration is being used.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.BaseEndpoint", new XmlComment(@"the base class all fast endpoints inherit from", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.BaseEndpoint.Configure", new XmlComment(@"use this method to configure how the endpoint should be listening to incoming requests.
HINT: it is only called once during endpoint auto registration during app startup.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Endpoint`1", new XmlComment(@"use this base class for defining endpoints that only use a request dto and don't use a response dto.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointWithMapper`2", new XmlComment(@"use this base class for defining endpoints that only use a request dto and don't use a response dto but uses a request mapper.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointWithMapper`2.Map", new XmlComment(@"the entity mapper for the endpoint
HINT: entity mappers are singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Endpoint`2", new XmlComment(@"use this base class for defining endpoints that use both request and response dtos.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.HandleAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.ExecuteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint that returns the response dto. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.TryResolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.TryResolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Resolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Resolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.CreateScope", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.TryResolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.TryResolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Resolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Resolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.PublishAsync``1(``0,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.ProcessorState``1", new XmlComment(@"retrieve the common processor state for this endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnBeforeValidate(`0)", new XmlComment(@"override this method if you'd like to do something to the request dto before it gets validated.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnBeforeValidateAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"override this method if you'd like to do something to the request dto before it gets validated.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnAfterValidate(`0)", new XmlComment(@"override this method if you'd like to do something to the request dto after it gets validated.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnAfterValidateAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"override this method if you'd like to do something to the request dto after it gets validated.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnBeforeHandle(`0)", new XmlComment(@"override this method if you'd like to do something to the request dto before the handler is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnBeforeHandleAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"override this method if you'd like to do something to the request dto before the handler is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnAfterHandle(`0,`1)", new XmlComment(@"override this method if you'd like to do something after the handler is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"res", @"the response dto that was sent to the client", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnAfterHandleAsync(`0,`1,System.Threading.CancellationToken)", new XmlComment(@"override this method if you'd like to do something after the handler is executed.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the request dto", null, false), new XmlParameterComment(@"res", @"the response dto that was sent to the client", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnValidationFailed", new XmlComment(@"override this method if you'd like to do something when a validation failure occurs.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.OnValidationFailedAsync(System.Threading.CancellationToken)", new XmlComment(@"override this method if you'd like to do something when a validation failure occurs.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Response", new XmlComment(@"the response object that is serialized to the response stream.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.User", new XmlComment(@"the current user principal", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Config", new XmlComment(@"gives access to the app configuration.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Env", new XmlComment(@"gives access to the hosting environment", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Logger", new XmlComment(@"the logger for the current endpoint type", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.BaseURL", new XmlComment(@"the base url of the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.HttpMethod", new XmlComment(@"the http method of the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Form", new XmlComment(@"the form sent with the request. only populated if content-type is 'application/x-www-form-urlencoded' or 'multipart/form-data'", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.Files", new XmlComment(@"the files sent with the request. only populated when content-type is 'multipart/form-data'", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`2.ResponseStarted", new XmlComment(@"get or set whether the response has started. you'd only use this if you're writing to the response stream by yourself.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.PostProcessor``1", new XmlComment(@"configure a  post-processor to be executed after the main handler function is done. call this method multiple times to add multiple post-processors.
processors are executed in the order they are configured in the endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.PostProcessors(FastEndpoints.IPostProcessor{`0,`1}[])", new XmlComment(@"configure a collection of post-processors to be executed after the main handler function is done. processors are executed in the order they are  defined
here.", null, null, null, null, false, null, [new XmlParameterComment(@"postProcessors", @"the post processors to be executed", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.PreProcessor``1", new XmlComment(@"configure a  pre-processor to be executed before the main handler function is called. call this method multiple times to add multiple pre-processors.
processors are executed in the order they are configured in the endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.PreProcessors(FastEndpoints.IPreProcessor{`0}[])", new XmlComment(@"configure a collection of pre-processors to be executed before the main handler function is called. processors are executed in the order they are defined
here.", null, null, null, null, false, null, [new XmlParameterComment(@"preProcessors", @"the pre-processors to be executed", null, false)], null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Routes(System.String[])", new XmlComment(@"specify one or more route patterns this endpoint should be listening for", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Verbs(FastEndpoints.Http[])", new XmlComment(@"specify one or more http method verbs this endpoint should be accepting requests for", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Endpoint`2.Verbs(System.String[])", new XmlComment(@"specify one or more http method verbs this endpoint should be accepting requests for", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Endpoint`3", new XmlComment(@"use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity
using a seperate entity mapper.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Endpoint`3.Map", new XmlComment(@"the entity mapper for the endpoint
HINT: entity mappers are singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointWithoutRequest", new XmlComment(@"use this base class for defining endpoints that doesn't need a request dto. usually used for routes that doesn't have any parameters.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest.HandleAsync(System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest.HandleAsync(FastEndpoints.EmptyRequest,System.Threading.CancellationToken)", new XmlComment(@"override the HandleAsync(CancellationToken ct) method instead of using this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest.ExecuteAsync(System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest.ExecuteAsync(FastEndpoints.EmptyRequest,System.Threading.CancellationToken)", new XmlComment(@"override the ExecuteAsync(CancellationToken ct) method instead of using this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointWithoutRequest`1", new XmlComment(@"use this base class for defining endpoints that doesn't need a request dto but return a response dto.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest`1.HandleAsync(System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest`1.HandleAsync(FastEndpoints.EmptyRequest,System.Threading.CancellationToken)", new XmlComment(@"override the HandleAsync(CancellationToken ct) method instead of using this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest`1.ExecuteAsync(System.Threading.CancellationToken)", new XmlComment(@"the handler method for the endpoint that returns the response dto. this method is called for each request received.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithoutRequest`1.ExecuteAsync(FastEndpoints.EmptyRequest,System.Threading.CancellationToken)", new XmlComment(@"override the ExecuteAsync(CancellationToken ct) method instead of using this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointWithoutRequest`2", new XmlComment(@"use this base class for defining endpoints that doesn't need a request dto but return a response dto and uses a response mapper.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointWithoutRequest`2.Map", new XmlComment(@"the entity mapper for the endpoint
HINT: entity mappers are singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointWithMapping`3", new XmlComment(@"use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointWithMapping`3.MapToEntity(`0)", new XmlComment(@"override this method and place the logic for mapping the request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithMapping`3.MapToEntityAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"override this method and place the logic for mapping the request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto to map from", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithMapping`3.MapFromEntity(`2)", new XmlComment(@"override this method and place the logic for mapping a domain entity to a response dto", null, null, null, null, false, null, [new XmlParameterComment(@"e", @"the domain entity to map from", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointWithMapping`3.MapFromEntityAsync(`2,System.Threading.CancellationToken)", new XmlComment(@"override this method and place the logic for mapping a domain entity to a response dto", null, null, null, null, false, null, [new XmlParameterComment(@"e", @"the domain entity to map from", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IResponseSender", new XmlComment(@"target this interface type for creating your own custom response sending methods.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IResponseSender.HttpContext", new XmlComment(@"the http context of the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IResponseSender.ValidationFailures", new XmlComment(@"validation failures collection for the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IResponseSender.Definition", new XmlComment(@"gets the endpoint definition which contains all the configuration info for the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ResponseSender`2", new XmlComment(@"this class encapsulates the default response sending methods for endpoints.
you can add your own custom send methods by writing extension methods targeting IResponseSender interface.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.#ctor(FastEndpoints.Endpoint{`0,`1})", new XmlComment(@"this class encapsulates the default response sending methods for endpoints.
you can add your own custom send methods by writing extension methods targeting IResponseSender interface.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.AcceptedAtAsync``1(System.Object,`1,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 202 accepted response with a location header containing where the resource can be retrieved from.
            HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint,
specify the 'routeNumber' argument.WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload
that accepts a string endpoint name instead.", null, null, null, null, false, null, [new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"verb", @"only useful when pointing to a multi verb endpoint", null, false), new XmlParameterComment(@"routeNumber", @"only useful when pointing to a multi route endpoint", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.AcceptedAtAsync(System.String,System.Object,`1,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 202 accepted response with a location header containing where the resource can be retrieved from.
            WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi
route endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"endpointName", @"the name of the endpoint to use for link generation (openapi route id)", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.BytesAsync(System.Byte[],System.String,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send a byte array to the client", null, null, null, null, false, null, [new XmlParameterComment(@"bytes", @"the bytes to send", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.CreatedAtAsync``1(System.Object,`1,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 201 created response with a location header containing where the resource can be retrieved from.
            HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint,
specify the 'routeNumber' argument.WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload
that accepts a string endpoint name instead.", null, null, null, null, false, null, [new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"verb", @"only useful when pointing to a multi verb endpoint", null, false), new XmlParameterComment(@"routeNumber", @"only useful when pointing to a multi route endpoint", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.CreatedAtAsync(System.String,System.Object,`1,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 201 created response with a location header containing where the resource can be retrieved from.
            WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi
route endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"endpointName", @"the name of the endpoint to use for link generation (openapi route id)", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.EmptyJsonObject(System.Threading.CancellationToken)", new XmlComment(@"send an empty json object in the body", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.ErrorsAsync(System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send a 400 bad request with error details of the current validation failures", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the status code for the error response", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.EventStreamAsync``1(System.String,System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)", new XmlComment(@"start an asynchronous ""server-sent-events"" data stream for the client with items of the same type, without blocking any threads", null, null, null, null, false, null, [new XmlParameterComment(@"eventName", @"the name of the event stream", null, false), new XmlParameterComment(@"eventStream", @"an IAsyncEnumerable that is the source of the data", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.EventStreamAsync(System.Collections.Generic.IAsyncEnumerable{FastEndpoints.StreamItem},System.Threading.CancellationToken)", new XmlComment(@"start an asynchronous ""server-sent-events"" data stream for the client with items that might be of different types, without blocking any threads", null, null, null, null, false, null, [new XmlParameterComment(@"eventStream", @"an IAsyncEnumerable of stream items that is the source of the data", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.FileAsync(System.IO.FileInfo,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send a file to the client", null, null, null, null, false, null, [new XmlParameterComment(@"fileInfo", @"", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.ForbiddenAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 403 unauthorized response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.HeadersAsync(System.Action{Microsoft.AspNetCore.Http.IHeaderDictionary},System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send headers in response to a HEAD request", null, null, null, null, false, null, [new XmlParameterComment(@"headers", @"an action to be performed on the headers dictionary of the response", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.InterceptedAsync(System.Object,System.Int32,System.Threading.CancellationToken)", new XmlComment(@"sends an object serialized as json to the client. if a response interceptor has been defined,
then that will be executed before the normal response is sent.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.NoContentAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 204 no content response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.NotModifiedAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 304 not modified response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.NotFoundAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 404 not found response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.OkAsync(`1,System.Threading.CancellationToken)", new XmlComment(@"send an http 200 ok response with the supplied response dto serialized as json to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.OkAsync(`1)", new XmlComment(@"send an http 200 ok response with the supplied response dto serialized as json to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.OkAsync(System.Threading.CancellationToken)", new XmlComment(@"send an http 200 ok response without a body.", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.OkAsync", new XmlComment(@"send an http 200 ok response without a body.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.RedirectAsync(System.String,System.Boolean,System.Boolean)", new XmlComment(@"send a 302/301 redirect response", null, null, null, null, false, null, [new XmlParameterComment(@"location", @"the location to redirect to", null, false), new XmlParameterComment(@"isPermanent", @"set to true for a 301 redirect. 302 is the default.", null, false), new XmlParameterComment(@"allowRemoteRedirects", @"set to true if it's ok to redirect to remote addresses, which is prone to open redirect attacks.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.ResponseAsync(`1,System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send the supplied response dto serialized as json to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.ResultAsync(Microsoft.AspNetCore.Http.IResult)", new XmlComment(@"execute and send any IResult produced by the Results class in minimal apis.", null, null, null, null, false, null, [new XmlParameterComment(@"result", @"            the IResult instance to execute such as:
            ```Results.Forbid();
Results.Ok(...);```", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.StatusCodeAsync(System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send any http status code", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.StreamAsync(System.IO.Stream,System.String,System.Nullable{System.Int64},System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send the contents of a stream to the client", null, null, null, null, false, null, [new XmlParameterComment(@"stream", @"the stream to read the data from", null, false), new XmlParameterComment(@"fileName", @"and optional file name to set in the content-disposition header", null, false), new XmlParameterComment(@"fileLengthBytes", @"optional total size of the file/stream", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.StringAsync(System.String,System.Int32,System.String,System.Threading.CancellationToken)", new XmlComment(@"send the supplied string content to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"content", @"the string to write to the response body", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"contentType", @"optional content type header value", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"M:FastEndpoints.ResponseSender`2.UnauthorizedAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 401 unauthorized response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used", null, false)], null));
            cache.Add(@"T:FastEndpoints.EndpointFactory", new XmlComment(@"the default endpoint factory.
it creates an instance of the endpoint and injects both constructor and property dependencies.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointFactory.Create(FastEndpoints.EndpointDefinition,Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"this method is called per each request.", null, null, null, null, false, null, [new XmlParameterComment(@"definition", @"the endpoint definition", null, false), new XmlParameterComment(@"ctx", @"the http context for the current request", null, false)], null));
            cache.Add(@"T:FastEndpoints.IEndpointFactory", new XmlComment(@"interface for the creation of endpoints.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEndpointFactory.Create(FastEndpoints.EndpointDefinition,Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"returns the instantiated fast endpoint from a given EndpointDefinition and HttpContext", null, null, null, null, false, null, [new XmlParameterComment(@"definition", @"the endpoint definition for the current request", null, false), new XmlParameterComment(@"ctx", @"the http context of the current request", null, false)], null));
            cache.Add(@"T:FastEndpoints.Ep.Req`1.Res`1", new XmlComment(@"specify the response dto type of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.Req`1.Res`1.Map`1", new XmlComment(@"specify the mapper type of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.Req`1.NoRes", new XmlComment(@"specifies that the endpoint has no response dto", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.Req`1.NoRes.Map`1", new XmlComment(@"specify the request mapper type of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.NoReq.NoRes", new XmlComment(@"specifies that the endpoint has no response dto", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.NoReq.Res`1", new XmlComment(@"specify the response dto type of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Ep.NoReq.Res`1.Map`1", new XmlComment(@"specify the mapper type of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyConfig.InMemoryCacheSize", new XmlComment(@"the in-memory output cache storage size. default value is 1024 mb.
when this limit is exceeded, no new responses will be cached until older entries are evicted.
this setting will not be applicable if using some other cache store such as redis.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyConfig.MaxResponseBodySize", new XmlComment(@"the largest cacheable size of the response body. default is set to 128 mb.
if the response body exceeds this limit, it will not be cached.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyConfig.UseCaseSensitivePaths", new XmlComment(@"set to `true` if request paths are case-sensitive. default is to treat paths as case-insensitive.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IdempotencyExtensions.AddIdempotency(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FastEndpoints.IdempotencyConfig})", new XmlComment(@"enable idempotency features", null, null, null, null, false, null, [new XmlParameterComment(@"cfg", @"global configuration settings for idempotency middleware", null, false)], null));
            cache.Add(@"T:FastEndpoints.IdempotencyOptions", new XmlComment(@"idempotency settings for an endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.HeaderName", new XmlComment(@"the header name that will contain the idempotency key. defaults to `Idempotency-Key`", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.AdditionalHeaders", new XmlComment(@"any additional headers that should participate in the generation of the cache-key.
see the source/definition for the list of default additional headers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.IgnoreRequestBody", new XmlComment(@"by default, the contents of the request body (form data/json) is taken into consideration when determining the uniqueness of incoming requests even if the
idempotency-key is the same among them. i.e. if two different requests come in with the same idempotency-key but with different request body content, they
will be  considered to be unique requests and the endpoint will be executed for each request.", null, @"this involves buffering the request body content per each request in order to generate a sha512 hash of the incoming body content. if the clients making
requests are under strict quality control and are guaranteed to not reuse idempotency keys, you can set this to `true` to prevent the hashing of
request body content.", null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.CacheDuration", new XmlComment(@"determines how long the cached responses will remain in the cache store before being evicted.
defaults to 10 minutes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.AddHeaderToResponse", new XmlComment(@"by default, the idempotency header will be automatically added to the response headers collection. set `false` to prevent that from happening.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.SwaggerHeaderDescription", new XmlComment(@"the description text for the swagger request header parameter", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.SwaggerExampleGenerator", new XmlComment(@"a function to generate an example value for the swagger request param header", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IdempotencyOptions.SwaggerHeaderType", new XmlComment(@"the type/format of the swagger example value", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEndpoint", new XmlComment(@"the common interface implemented by all endpoints", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEndpoint.GetName``1(System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.String)", new XmlComment(@"retrieves the name of a given endpoint by supplying its type. the name is generated using the Func&lt;EndpointNameGenerationContext, string&gt; EndpointOptions.NameGenerator func.", null, null, null, null, false, null, [new XmlParameterComment(@"verb", @"the http verb, if the target is a multi-verb endpoint.", null, false), new XmlParameterComment(@"routeNumber", @"the route number, if the target is a multi route endpoint.", null, false), new XmlParameterComment(@"tagPrefix", @"tag prefix", null, false)], null));
            cache.Add(@"T:FastEndpoints.INoRequest", new XmlComment(@"marker interface for endpoint base classes without a request dto", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IHasMapper`1", new XmlComment(@"marker/constraint for endpoints that have a mapper generic argument", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IHasMapper`1.Map", new XmlComment(@"the mapper property", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IMapper", new XmlComment(@"marker interface for entity mappers", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IRequestMapper", new XmlComment(@"marker interface for request only mappers", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IRequestMapper`2", new XmlComment(@"use this interface to implement a domain entity mapper for your endpoints that only has a request dto and no response dto.
HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IRequestMapper`2.ToEntity(`0)", new XmlComment(@"implement this method and place the logic for mapping the request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.IRequestMapper`2.ToEntityAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"implement this method and place the logic for mapping the request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto to map from", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IRequestMapper`2.UpdateEntity(`0,`1)", new XmlComment(@"implement this method and place the logic for mapping the updated request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto to update from", null, false), new XmlParameterComment(@"e", @"the domain entity to update", null, false)], null));
            cache.Add(@"M:FastEndpoints.IRequestMapper`2.UpdateEntityAsync(`0,`1,System.Threading.CancellationToken)", new XmlComment(@"implement this method and place the logic for mapping the updated request dto to the desired domain entity", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the request dto to update from", null, false), new XmlParameterComment(@"e", @"the domain entity to update", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IResponseMapper", new XmlComment(@"marker interface for response only mappers", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IResponseMapper`2", new XmlComment(@"use this interface to implement a domain entity mapper for your endpoints that only has a response dto and no request dto.
HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IResponseMapper`2.FromEntity(`1)", new XmlComment(@"implement this method and place the logic for mapping a domain entity to a response dto", null, null, null, null, false, null, [new XmlParameterComment(@"e", @"the domain entity to map from", null, false)], null));
            cache.Add(@"M:FastEndpoints.IResponseMapper`2.FromEntityAsync(`1,System.Threading.CancellationToken)", new XmlComment(@"implement this method and place the logic for mapping a domain entity to a response dto", null, null, null, null, false, null, [new XmlParameterComment(@"e", @"the domain entity to map from", null, false), new XmlParameterComment(@"ct", @"a cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.Mapper`3", new XmlComment(@"use this base class to define domain entity mappers for your endpoints.
HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RequestMapper`2", new XmlComment(@"use this base class to define a domain entity mapper for your endpoints that only has a request dto and no response dto.
HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ResponseMapper`2", new XmlComment(@"use this base class to define a domain entity mapper for your endpoints that only has a response dto and no request dto.
HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.GlobalPostProcessor`1", new XmlComment(@"inherit this class to create a global post-processor with access to the common processor state of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.GlobalPostProcessor`1.PostProcessAsync(FastEndpoints.IPostProcessorContext,System.Threading.CancellationToken)", new XmlComment(@"not intended for direct external use.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.GlobalPostProcessor`1.PostProcessAsync(FastEndpoints.IPostProcessorContext,`0,System.Threading.CancellationToken)", new XmlComment(@"implement this method to define the post-processing logic using the provided context and state.", null, null, @"a Task representing the asynchronous operation.", null, false, null, [new XmlParameterComment(@"context", @"the context object encapsulating all necessary information for post-processing.", null, false), new XmlParameterComment(@"state", @"the common processor state object, derived from the HttpContext or newly instantiated.", null, false), new XmlParameterComment(@"ct", @"cancellation token.", null, false)], null));
            cache.Add(@"T:FastEndpoints.GlobalPreProcessor`1", new XmlComment(@"inherit this class to create a global pre-processor with access to the common processor state of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.GlobalPreProcessor`1.PreProcessAsync(FastEndpoints.IPreProcessorContext,System.Threading.CancellationToken)", new XmlComment(@"not intended for direct external use.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.GlobalPreProcessor`1.PreProcessAsync(FastEndpoints.IPreProcessorContext,`0,System.Threading.CancellationToken)", new XmlComment(@"this method is called with the given arguments when the pre-processor executes.", null, null, null, null, false, null, [new XmlParameterComment(@"context", @"the context object encapsulating all necessary information for pre-processing.", null, false), new XmlParameterComment(@"state", @"the common processor state object", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IPostProcessor", new XmlComment(@"defines the interface for a post-processor that can perform asynchronous post-processing tasks after a request has been handled.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IPostProcessor.PostProcessAsync(FastEndpoints.IPostProcessorContext,System.Threading.CancellationToken)", new XmlComment(@"asynchronously performs post-processing on the provided context.", null, null, @"a Task that represents the asynchronous post-process operation.", null, false, null, [new XmlParameterComment(@"context", @"the post-processor context containing request, response, and other processing details.", null, false), new XmlParameterComment(@"ct", @"the CancellationToken to observe while waiting for the task to complete.", null, false)], null));
            cache.Add(@"T:FastEndpoints.IPostProcessor`2", new XmlComment(@"defines the generic interface for a post-processor with specific types for the request and response,
enabling type-safe post-processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IPostProcessor`2.PostProcessAsync(FastEndpoints.IPostProcessorContext{`0,`1},System.Threading.CancellationToken)", new XmlComment(@"asynchronously performs post-processing on the provided context with specific request and response types.", null, null, @"a Task that represents the asynchronous post-process operation.", null, false, null, [new XmlParameterComment(@"context", @"the post-processor context containing the typed request, response, and other processing details.", null, false), new XmlParameterComment(@"ct", @"the CancellationToken to observe while waiting for the task to complete.", null, false)], null));
            cache.Add(@"T:FastEndpoints.IGlobalPostProcessor", new XmlComment(@"interface for defining global post-processors to be executed after the main endpoint handler is done", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPostProcessorContext", new XmlComment(@"defines the basic interface for a post-processor context, containing essential properties
to access request, response, and associated processing details.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.Request", new XmlComment(@"gets the request object, which may be null if request binding has failed.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.Response", new XmlComment(@"gets the response object, which may be null if the response is not available.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.HttpContext", new XmlComment(@"gets the HttpContext IPostProcessorContext.HttpContext associated with the current request and response.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.ValidationFailures", new XmlComment(@"gets a read-only collection of ValidationFailure that occurred during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.ExceptionDispatchInfo", new XmlComment(@"gets information about any exception that was thrown during processing.
this will be null if no exception has occurred.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.HasExceptionOccurred", new XmlComment(@"determines if an exception has occurred during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext.HasValidationFailures", new XmlComment(@"determines if any validation failures have occurred during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IPostProcessorContext.MarkExceptionAsHandled", new XmlComment(@"call this method if you're handling the captured exception (via ExceptionDispatchInfo? IPostProcessorContext.ExceptionDispatchInfo) in a post-processor and the exception should not be thrown.
not calling this method will result in the captured exception being thrown after all the post-processors have run.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPostProcessorContext`2", new XmlComment(@"defines the generic interface for a post-processor context with specific types for the request and response.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext`2.Request", new XmlComment(@"gets the request object of the generic type TRequest,
which may be null if request binding has failed.
this hides the non-generic version from IPostProcessorContext.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPostProcessorContext`2.Response", new XmlComment(@"gets the response object of the generic type TResponse,
which may be null if the response is not available. this hides the non-generic
version from IPostProcessorContext.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPreProcessor", new XmlComment(@"defines the interface for a pre-processor that can perform asynchronous pre-processing tasks before a request has been handled.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IPreProcessor.PreProcessAsync(FastEndpoints.IPreProcessorContext,System.Threading.CancellationToken)", new XmlComment(@"asynchronously performs pre-processing on the provided context.", null, null, @"a Task that represents the asynchronous pre-process operation.", null, false, null, [new XmlParameterComment(@"context", @"the pre-processor context containing request, and other processing details.", null, false), new XmlParameterComment(@"ct", @"the CancellationToken to observe while waiting for the task to complete.", null, false)], null));
            cache.Add(@"T:FastEndpoints.IPreProcessor`1", new XmlComment(@"defines the generic interface for a pre-processor with specific types for the request,
enabling type-safe pre-processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IPreProcessor`1.PreProcessAsync(FastEndpoints.IPreProcessorContext{`0},System.Threading.CancellationToken)", new XmlComment(@"asynchronously performs pre-processing on the provided context with a specific request type.", null, null, @"a Task that represents the asynchronous pre-process operation.", null, false, null, [new XmlParameterComment(@"context", @"the pre-processor context containing the typed request, and other processing details.", null, false), new XmlParameterComment(@"ct", @"The CancellationToken to observe while waiting for the task to complete.", null, false)], null));
            cache.Add(@"T:FastEndpoints.IGlobalPreProcessor", new XmlComment(@"interface for defining global pre-processors to be executed before the main endpoint handler is called", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPreProcessorContext", new XmlComment(@"defines the basic interface for a pre-processor context, containing essential properties to access request, and associated processing details.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPreProcessorContext.Request", new XmlComment(@"gets the request object. may be null if request binding has failed.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPreProcessorContext.HttpContext", new XmlComment(@"gets the HttpContext IPreProcessorContext.HttpContext associated with the current request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPreProcessorContext.ValidationFailures", new XmlComment(@"gets a collection of ValidationFailure that occurred during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPreProcessorContext.HasValidationFailures", new XmlComment(@"determines if any validation failures have occurred during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IPreProcessorContext`1", new XmlComment(@"defines the generic interface for a pre-processor context with a specific type for the request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IPreProcessorContext`1.Request", new XmlComment(@"gets the request object of the generic type TRequest.
may be null if request binding has failed.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IProcessor", new XmlComment(@"base marker interface for pre &amp; post processor interfaces", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IResponseInterceptor", new XmlComment(@"interface for defining a response interceptor to be executed before the main endpoint handler executes", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IResponseInterceptor.InterceptResponseAsync(System.Object,System.Int32,Microsoft.AspNetCore.Http.HttpContext,System.Collections.Generic.IReadOnlyCollection{FluentValidation.Results.ValidationFailure},System.Threading.CancellationToken)", new XmlComment(@"implement this method to intercept the http response with the use of SendInterceptedAsync() method.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the response object", null, false), new XmlParameterComment(@"statusCode", @"", null, false), new XmlParameterComment(@"ctx", @"the http context of the current request", null, false), new XmlParameterComment(@"failures", @"the collection of validation failures for the endpoint", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.Order", new XmlComment(@"enum used to specify whether to execute global pre/post processors before endpoint level processors", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Order.Before", new XmlComment(@"execute global processors before the endpoint level processors", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Order.After", new XmlComment(@"execute global processors after the endpoint level processors", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PostProcessor`3", new XmlComment(@"inherit this class to create a post-processor with access to the common processor state of the endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.PostProcessor`3.PostProcessAsync(FastEndpoints.IPostProcessorContext{`0,`2},System.Threading.CancellationToken)", new XmlComment(@"not intended for direct external use.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.PostProcessor`3.PostProcessAsync(FastEndpoints.IPostProcessorContext{`0,`2},`1,System.Threading.CancellationToken)", new XmlComment(@"implement this method to define the post-processing logic using the provided context and state.", null, null, @"a Task representing the asynchronous operation.", null, false, null, [new XmlParameterComment(@"context", @"the context object encapsulating all necessary information for post-processing.", null, false), new XmlParameterComment(@"state", @"the common processor state object, derived from the HttpContext or newly instantiated.", null, false), new XmlParameterComment(@"ct", @"cancellation token.", null, false)], null));
            cache.Add(@"T:FastEndpoints.PostProcessorContext`2", new XmlComment(@"represents the context for a post-processing operation with a request and response pair.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PostProcessorContext`2.Request", new XmlComment(@"gets the request associated with the post-processing context.
may be null if request binding has failed.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PostProcessorContext`2.Response", new XmlComment(@"gets the response associated with the post-processing context.
may be null if the response is not available or not yet created.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PostProcessorContext`2.HttpContext", new XmlComment(@"gets the HttpContext PostProcessorContext&lt;TRequest, TResponse&gt;.HttpContext associated with the current request and response.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PostProcessorContext`2.ValidationFailures", new XmlComment(@"gets a collection of ValidationFailure instances that describe any validation failures.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PostProcessorContext`2.ExceptionDispatchInfo", new XmlComment(@"gets the ExceptionDispatchInfo? PostProcessorContext&lt;TRequest, TResponse&gt;.ExceptionDispatchInfo if an exception was captured during the processing.
may be null if no exception was captured.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PreProcessor`2", new XmlComment(@"inherit this class to create a pre-processor with access to the common processor state of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.PreProcessor`2.PreProcessAsync(FastEndpoints.IPreProcessorContext{`0},System.Threading.CancellationToken)", new XmlComment(@"not intended for direct external use.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.PreProcessor`2.PreProcessAsync(FastEndpoints.IPreProcessorContext{`0},`1,System.Threading.CancellationToken)", new XmlComment(@"this method is called with the given arguments when the pre-processor executes.", null, null, null, null, false, null, [new XmlParameterComment(@"context", @"the context object encapsulating all necessary information for pre-processing.", null, false), new XmlParameterComment(@"state", @"the common processor state object", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.PreProcessorContext`1", new XmlComment(@"represents the context for a pre-processing operation with a request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PreProcessorContext`1.Request", new XmlComment(@"gets the request associated with the pre-processing context.
may be null if model binding has failed.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PreProcessorContext`1.HttpContext", new XmlComment(@"gets the HttpContext PreProcessorContext&lt;TRequest&gt;.HttpContext associated with the current request.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PreProcessorContext`1.ValidationFailures", new XmlComment(@"gets a collection of ValidationFailure instances that describe any validation failures.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PreProcessorAttribute`1", new XmlComment(@"generic attribute for adding a pre-processor to an endpoint. only effective when attribute based endpoint configuration is being used.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.PostProcessorAttribute`1", new XmlComment(@"generic attribute for adding a post-processor to an endpoint. only effective when attribute based endpoint configuration is being used.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EndpointSummary", new XmlComment(@"a class used for providing a textual description about an endpoint for swagger", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.Item(System.Int32)", new XmlComment(@"indexer for the response descriptions", null, null, @"the text description", null, false, null, [new XmlParameterComment(@"statusCode", @"the status code of the response you want to access", null, false)], null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.Summary", new XmlComment(@"the short summary of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.Description", new XmlComment(@"the long description of the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.RequestExamples", new XmlComment(@"specify multiple request examples by adding to this collection.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.ExampleRequest", new XmlComment(@"an example request object to be used in swagger/ openapi.
multiple examples can be specified by setting this property multiple times or by adding to the ICollection&lt;RequestExample&gt; EndpointSummary.RequestExamples collection.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.Params", new XmlComment(@"the descriptions for endpoint parameters. you can add descriptions for route/query params and request dto properties.
what you specify here will take precedence over xml comments of dto classes (if they are also specified).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.Responses", new XmlComment(@"the descriptions of the different responses/ status codes an endpoint can return", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointSummary.ResponseExamples", new XmlComment(@"the response examples for each status code", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointSummary.ResponseParam``1(System.Int32,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)", new XmlComment(@"add a description for a given property of a given response dto", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the status code of the response you want to add the descriptions for", null, false), new XmlParameterComment(@"property", @"a member expression for specifying which property the description is for", null, false), new XmlParameterComment(@"description", @"the description text", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointSummary.ResponseParam``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)", new XmlComment(@"add a description for a given property of the 200 response dto", null, null, null, null, false, null, [new XmlParameterComment(@"property", @"a member expression for specifying which property the description is for", null, false), new XmlParameterComment(@"description", @"the description text", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointSummary.Response``1(System.Int32,System.String,System.String,``0)", new XmlComment(@"            add a response description to the swagger document
            NOTE: if you use this method, the default 200 response is automatically removed, and you'd have to specify the 200 response yourself if it
applies to your endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"http status code", null, false), new XmlParameterComment(@"description", @"the description of the response", null, false), new XmlParameterComment(@"contentType", @"the media/content type of the response", null, false), new XmlParameterComment(@"example", @"and example response dto instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.EndpointSummary.Response(System.Int32,System.String,System.String)", new XmlComment(@"add a response description that doesn't have a response dto to the swagger document
NOTE: if you use  this method, the default 200 response is automatically removed, and you'd have to specify the 200 response yourself if it
applies to your endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"http status code", null, false), new XmlParameterComment(@"description", @"the description of the response", null, false), new XmlParameterComment(@"contentType", @"the media/content type of the response", null, false)], null));
            cache.Add(@"T:FastEndpoints.EndpointSummary`1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EndpointSummary`1.RequestParam(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)", new XmlComment(@"add a description for a request param for a given property of the request dto", null, null, null, null, false, null, [new XmlParameterComment(@"property", @"a member expression for specifying which property the description is for", null, false), new XmlParameterComment(@"description", @"the description text", null, false)], null));
            cache.Add(@"T:FastEndpoints.Summary`1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Summary`2", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RequestExample", new XmlComment(@"represents a swagger example request analogous to an OpenApiExample", null, null, null, null, false, null, [new XmlParameterComment(@"value", @"the actual example request object", null, false), new XmlParameterComment(@"label", @"the label/name for this example request", null, false), new XmlParameterComment(@"summary", @"the summary text of this example request", null, false), new XmlParameterComment(@"description", @"the description of this example request", null, false)], null));
            cache.Add(@"M:FastEndpoints.RequestExample.#ctor(System.Object,System.String,System.String,System.String)", new XmlComment(@"represents a swagger example request analogous to an OpenApiExample", null, null, null, null, false, null, [new XmlParameterComment(@"value", @"the actual example request object", null, false), new XmlParameterComment(@"label", @"the label/name for this example request", null, false), new XmlParameterComment(@"summary", @"the summary text of this example request", null, false), new XmlParameterComment(@"description", @"the description of this example request", null, false)], null));
            cache.Add(@"P:FastEndpoints.RequestExample.Summary", new XmlComment(@"the summary text of this example request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.RequestExample.Description", new XmlComment(@"the description of this example request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.RequestExample.Value", new XmlComment(@"the actual example request object", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.RequestExample.Label", new XmlComment(@"the label/name for this example request", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ResponseHeader", new XmlComment(@"describes a swagger response header for a certain response dto", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ResponseHeader.Description", new XmlComment(@"description for the header", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ResponseHeader.Example", new XmlComment(@"an example header value", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ExceptionHandlerExtensions.UseDefaultExceptionHandler(Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.Extensions.Logging.ILogger,System.Boolean,System.Boolean)", new XmlComment(@"registers the default global exception handler which will log the exceptions on the server and return a user-friendly json response to the client
when unhandled exceptions occur.
TIP: when using this exception handler, you may want to turn off the asp.net core exception middleware logging to avoid duplication like so:
```""Logging"": { ""LogLevel"": { ""Default"": ""Warning"", ""Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware"": ""None"" } }```", null, null, null, null, false, null, [new XmlParameterComment(@"logger", @"an optional logger instance", null, false), new XmlParameterComment(@"logStructuredException", @"set to true if you'd like to log the error in a structured manner", null, false), new XmlParameterComment(@"useGenericReason", @"set to true if you don't want to expose the actual exception reason in the json response sent to the client", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.TryResolve``1(Microsoft.AspNetCore.Http.HttpContext,System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name to resolve a keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.TryResolve(Microsoft.AspNetCore.Http.HttpContext,System.Type,System.String)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"the key name to resolve a keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.Resolve``1(Microsoft.AspNetCore.Http.HttpContext,System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"keyName", @"the key name to resolve a keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.Resolve(Microsoft.AspNetCore.Http.HttpContext,System.Type,System.String)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false), new XmlParameterComment(@"keyName", @"the key name to resolve a keyed service", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.TryResolve``1(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.TryResolve(Microsoft.AspNetCore.Http.HttpContext,System.Type)", new XmlComment(@"try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.Resolve``1(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.Resolve(Microsoft.AspNetCore.Http.HttpContext,System.Type)", new XmlComment(@"resolve an instance for the given type from the dependency injection container. will throw if unresolvable.", null, null, null, null, false, null, [new XmlParameterComment(@"typeOfService", @"the type of the service to resolve", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.MarkResponseStart(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"marks the current response as started so that bool HttpContextExtensions.ResponseStarted(HttpContext ctx) can return the correct result.", null, null, null, null, false, null, [new XmlParameterComment(@"ctx", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.ResponseStarted(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"check if the current response has already started or not.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.ProcessorState``1(Microsoft.AspNetCore.Http.HttpContext)", new XmlComment(@"retrieve the common processor state for the current http context.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpContextExtensions.PopulateResponseHeadersFromResponseDto(Microsoft.AspNetCore.Http.HttpContext,System.Object)", new XmlComment(@"adds headers to the http response by reading response dto properties decorated with the [ToHeader(...)] attribute", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the response dto instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendAcceptedAtAsync``1(Microsoft.AspNetCore.Http.HttpResponse,System.Object,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendAcceptedAtAsync(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Object,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendAsync``1(Microsoft.AspNetCore.Http.HttpResponse,``0,System.Int32,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendAtAsync``1(Microsoft.AspNetCore.Http.HttpResponse,System.Int32,System.Object,System.Boolean,System.String,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendAtAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Int32,System.String,System.Object,System.Boolean,System.String,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendBytesAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Byte[],System.String,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendCreatedAtAsync``1(Microsoft.AspNetCore.Http.HttpResponse,System.Object,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendCreatedAtAsync(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Object,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendEmptyJsonObject(Microsoft.AspNetCore.Http.HttpResponse,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendErrorsAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Collections.Generic.List{FluentValidation.Results.ValidationFailure},System.Int32,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendEventStreamAsync``1(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendEventStreamAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Collections.Generic.IAsyncEnumerable{FastEndpoints.StreamItem},System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendFileAsync(Microsoft.AspNetCore.Http.HttpResponse,System.IO.FileInfo,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendForbiddenAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendHeadersAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Action{Microsoft.AspNetCore.Http.IHeaderDictionary},System.Int32,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendNoContentAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendNotModifiedAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendNotFoundAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendOkAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendOkAsync``1(Microsoft.AspNetCore.Http.HttpResponse,``0,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendRedirectAsync(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendResultAsync(Microsoft.AspNetCore.Http.HttpResponse,Microsoft.AspNetCore.Http.IResult)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendStatusCodeAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Int32,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendStreamAsync(Microsoft.AspNetCore.Http.HttpResponse,System.IO.Stream,System.String,System.Nullable{System.Int64},System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendStringAsync(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Int32,System.String,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.SendUnauthorizedAsync(Microsoft.AspNetCore.Http.HttpResponse,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendAcceptedAtAsync``1(System.Object,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 202 accepted response with a location header containing where the resource can be retrieved from.
            HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint,
specify the 'routeNumber' argument.WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload
that accepts a string endpoint name instead.", null, null, null, null, false, null, [new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"verb", @"only useful when pointing to a multi verb endpoint", null, false), new XmlParameterComment(@"routeNumber", @"only useful when pointing to a multi route endpoint", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendAcceptedAtAsync(System.String,System.Object,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 202 accepted response with a location header containing where the resource can be retrieved from.
            WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi
route endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"endpointName", @"the name of the endpoint to use for link generation (openapi route id)", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendAsync``1(``0,System.Int32,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"send the supplied response dto serialized as json to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendAtAsync``1(System.Int32,System.Object,System.Boolean,System.String,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"            send a custom 20X (accepted/created) response with a location header containing where the resource can be retrieved from.
            HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint,
specify the 'routeNumber' argument.WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload
that accepts a string endpoint name instead.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the http status code to send", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"contentType", @"the content type for the response", null, false), new XmlParameterComment(@"verb", @"only useful when pointing to a multi verb endpoint", null, false), new XmlParameterComment(@"routeNumber", @"only useful when pointing to a multi route endpoint", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendAtAsync(System.Int32,System.String,System.Object,System.Boolean,System.String,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"            send a custom 20X (accepted/created) response with a location header containing where the resource can be retrieved from.
            WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi
route endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the http status code to send", null, false), new XmlParameterComment(@"endpointName", @"the name of the endpoint to use for link generation (openapi route id)", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"contentType", @"the content type for the response", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendBytesAsync(System.Byte[],System.String,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send a byte array to the client", null, null, null, null, false, null, [new XmlParameterComment(@"bytes", @"the bytes to send", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendCreatedAtAsync``1(System.Object,System.Object,System.Nullable{FastEndpoints.Http},System.Nullable{System.Int32},System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 201 created response with a location header containing where the resource can be retrieved from.
            HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint,
specify the 'routeNumber' argument.WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload
that accepts a string endpoint name instead.", null, null, null, null, false, null, [new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"verb", @"only useful when pointing to a multi verb endpoint", null, false), new XmlParameterComment(@"routeNumber", @"only useful when pointing to a multi route endpoint", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendCreatedAtAsync(System.String,System.Object,System.Object,System.Text.Json.Serialization.JsonSerializerContext,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"            send a 201 created response with a location header containing where the resource can be retrieved from.
            WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi
route endpoint.", null, null, null, null, false, null, [new XmlParameterComment(@"endpointName", @"the name of the endpoint to use for link generation (openapi route id)", null, false), new XmlParameterComment(@"routeValues", @"a route values object with key/value pairs of route information", null, false), new XmlParameterComment(@"responseBody", @"the content to be serialized in the response body", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"generateAbsoluteUrl", @"set to true for generating an absolute url instead of relative url for the location header", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendEmptyJsonObject(System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"send an empty json object in the body", null, null, null, null, false, null, [new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendErrorsAsync(System.Collections.Generic.List{FluentValidation.Results.ValidationFailure},System.Int32,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"send a 400 bad request with error details of the current validation failures", null, null, null, null, false, null, [new XmlParameterComment(@"failures", @"the collection of failures", null, false), new XmlParameterComment(@"statusCode", @"the http status code for the error response", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendEventStreamAsync``1(System.String,System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)", new XmlComment(@"start a ""server-sent-events"" data stream for the client asynchronously without blocking any threads", null, null, null, null, false, null, [new XmlParameterComment(@"eventName", @"the name of the event stream", null, false), new XmlParameterComment(@"eventStream", @"an IAsyncEnumerable that is the source of the data", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendEventStreamAsync(System.Collections.Generic.IAsyncEnumerable{FastEndpoints.StreamItem},System.Threading.CancellationToken)", new XmlComment(@"start a ""server-sent-events"" data stream for the client asynchronously without blocking any threads", null, null, null, null, false, null, [new XmlParameterComment(@"eventStream", @"an IAsyncEnumerable that is the source of the data", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendFileAsync(System.IO.FileInfo,System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send a file to the client", null, null, null, null, false, null, [new XmlParameterComment(@"fileInfo", @"", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendForbiddenAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 403 unauthorized response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendHeadersAsync(System.Action{Microsoft.AspNetCore.Http.IHeaderDictionary},System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send headers in response to a HEAD request", null, null, null, null, false, null, [new XmlParameterComment(@"headers", @"an action to be performed on the headers dictionary of the response", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendNoContentAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 204 no content response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendNotModifiedAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 304 not modified response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendNotFoundAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 404 not found response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendOkAsync(System.Threading.CancellationToken)", new XmlComment(@"send an http 200 ok response without a body.", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendOkAsync``1(``0,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)", new XmlComment(@"send an http 200 ok response with the supplied response dto serialized as json to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the object to serialize to json", null, false), new XmlParameterComment(@"jsonSerializerContext", @"json serializer context if code generation is used", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendRedirectAsync(System.String,System.Boolean,System.Boolean)", new XmlComment(@"send a 302/301 redirect response", null, null, null, null, false, null, [new XmlParameterComment(@"location", @"the location to redirect to", null, false), new XmlParameterComment(@"isPermanent", @"set to true for a 301 redirect. 302 is the default.", null, false), new XmlParameterComment(@"allowRemoteRedirects", @"set to true if it's ok to redirect to remote addresses, which is prone to open redirect attacks.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendResultAsync(Microsoft.AspNetCore.Http.IResult)", new XmlComment(@"execute and send any IResult produced by the Results or TypedResults classes in minimal apis.", null, null, null, null, false, null, [new XmlParameterComment(@"result", @"            the IResult instance to execute such as from:
            ```- Results.Ok();
- TypedResults.NotFound();```", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendStatusCodeAsync(System.Int32,System.Threading.CancellationToken)", new XmlComment(@"send any http status code", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the http status code", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendStreamAsync(System.IO.Stream,System.String,System.Nullable{System.Int64},System.String,System.Nullable{System.DateTimeOffset},System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"send the contents of a stream to the client", null, null, null, null, false, null, [new XmlParameterComment(@"stream", @"the stream to read the data from", null, false), new XmlParameterComment(@"fileName", @"and optional file name to set in the content-disposition header", null, false), new XmlParameterComment(@"fileLengthBytes", @"optional total size of the file/stream", null, false), new XmlParameterComment(@"contentType", @"optional content type to set on the http response", null, false), new XmlParameterComment(@"lastModified", @"optional last modified date-time-offset for the data stream", null, false), new XmlParameterComment(@"enableRangeProcessing", @"optional switch for enabling range processing", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendStringAsync(System.String,System.Int32,System.String,System.Threading.CancellationToken)", new XmlComment(@"send the supplied string content to the client.", null, null, null, null, false, null, [new XmlParameterComment(@"content", @"the string to write to the response body", null, false), new XmlParameterComment(@"statusCode", @"optional custom http status code", null, false), new XmlParameterComment(@"contentType", @"optional content type header value", null, false), new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpResponseExtensions.<G>$8B7FDD3D869A4E98364DD81D882DB183.SendUnauthorizedAsync(System.Threading.CancellationToken)", new XmlComment(@"send a 401 unauthorized response", null, null, null, null, false, null, [new XmlParameterComment(@"cancellation", @"optional cancellation token. if not specified, the `HttpContext.RequestAborted` token is used.", null, false)], null));
            cache.Add(@"T:FastEndpoints.EndpointDiscoveryOptions", new XmlComment(@"defines how endpoint discovery and registration should be done at startup", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.Assemblies", new XmlComment(@"an optional collection of assemblies to discover endpoints from in addition to the auto discovered ones.
if bool EndpointDiscoveryOptions.DisableAutoDiscovery is set to true, this must be provided.
NOTE: not applicable when using FastEndpoints.Generator package", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.DisableAutoDiscovery", new XmlComment(@"set to true if only the provided Assemblies should be scanned for endpoints.
if IEnumerable&lt;Assembly&gt;? EndpointDiscoveryOptions.Assemblies is null and this is set to true, an exception will be thrown.
NOTE: not applicable when using FastEndpoints.Generator package", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.AssemblyFilter", new XmlComment(@"an optional predicate to filter out the final collection of assemblies before scanning for endpoints.
NOTE: not applicable when using FastEndpoints.Generator package", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.SourceGeneratorDiscoveredTypes", new XmlComment(@"when using the FastEndpoints.Generator package, do .AddRange(`&lt;AssemblyName&gt;.DiscoveredTypes.All`) on this property,
per referenced assembly if your solution has multiple projects, or simply assign to this property if there's only one project/assembly.
doing so will use the types discovered during source generation instead of reflection based type discovery.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.IncludeAbstractValidators", new XmlComment(@"by default only validators inheriting Validator&lt;TRequest&gt; are auto registered.
if you'd like to also include validators inheriting AbstractValidator&lt;T&gt;, set this to true.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.EndpointDiscoveryOptions.Filter", new XmlComment(@"a function to filter out types from auto discovery.
the function you set here will be executed for each discovered type during startup.
return 'false' from the function if you want to exclude a type from discovery.
return 'true' to include.
alternatively you can annotate the type/class with the DontRegisterAttribute to skip auto registration for that type.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IFeatureFlag", new XmlComment(@"implement this interface for creating a feature flag for an endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IFeatureFlag.Name", new XmlComment(@"optional name of the feature flag", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IFeatureFlag.IsEnabledAsync(FastEndpoints.IEndpoint)", new XmlComment(@"return `false` from this method to disable the endpoint during runtime.", null, null, null, null, false, null, [new XmlParameterComment(@"endpoint", @"the endpoint instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.MainExtensions.AddFastEndpoints(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FastEndpoints.EndpointDiscoveryOptions})", new XmlComment(@"adds the FastEndpoints services to the ASP.Net middleware pipeline", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"optionally specify the endpoint discovery options", null, false)], null));
            cache.Add(@"M:FastEndpoints.MainExtensions.UseFastEndpoints(Microsoft.AspNetCore.Builder.IApplicationBuilder,System.Action{FastEndpoints.Config})", new XmlComment(@"            finalizes auto discovery of endpoints and prepares FastEndpoints to start processing requests
            HINT: you can use IEndpointRouteBuilder MainExtensions.MapFastEndpoints(IEndpointRouteBuilder app, Action&lt;Config&gt;? configAction = null) instead of this method if you have some special
requirement such as using ""Startup.cs"", etc.", null, null, null, null, false, null, [new XmlParameterComment(@"configAction", @"an optional action to configure FastEndpoints", null, false)], null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.ProducesProblemFE``1(Microsoft.AspNetCore.Builder.RouteHandlerBuilder,System.Int32,System.String)", new XmlComment(@"adds produces metadata for a given type of error response dto", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the status code of the error response", null, false), new XmlParameterComment(@"contentType", @"content type header value", null, false)], null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.ProducesProblemFE(Microsoft.AspNetCore.Builder.RouteHandlerBuilder,System.Int32,System.String)", new XmlComment(@"adds produces metadata of type ErrorResponse to the endpoint description", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the status code of the error response", null, false), new XmlParameterComment(@"contentType", @"content type header value", null, false)], null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.ProducesProblemDetails(Microsoft.AspNetCore.Builder.RouteHandlerBuilder,System.Int32,System.String)", new XmlComment(@"adds produces metadata of type ProblemDetails (RFC7807 compatible) to the endpoint description", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"the status code of the error response", null, false), new XmlParameterComment(@"contentType", @"content type header value", null, false)], null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.ClearDefaultAccepts(Microsoft.AspNetCore.Builder.RouteHandlerBuilder)", new XmlComment(@"clears just the default ""accepts metadata"" from the endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.ClearDefaultProduces(Microsoft.AspNetCore.Builder.RouteHandlerBuilder,System.Int32[])", new XmlComment(@"clears any number of given ""produces metadata"" from the endpoint by supplying the status codes of the responses to remove.
not specifying any status codes will result in all produces metadata being removed.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCodes", @"one or more status codes of the defaults to remove", null, false)], null));
            cache.Add(@"M:FastEndpoints.RouteHandlerBuilderExtensions.Accepts``1(Microsoft.AspNetCore.Builder.RouteHandlerBuilder)", new XmlComment(@"override the default ""accepts metadata"" in order to accept any content-type from the client.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.CommandHandlerBase`1", new XmlComment(@"the base class from which all CommandHandler&lt;TCommand&gt; classes inherit from", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.CommandHandler`1", new XmlComment(@"inherit this base class if you'd like to manipulate validation state of the calling endpoint from within the command handler.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.CommandHandler`2", new XmlComment(@"inherit this base class if you'd like to manipulate validation state of the calling endpoint from within the command handler.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.MiddlewareExtensions.UseAntiforgeryFE(Microsoft.AspNetCore.Builder.IApplicationBuilder,System.Func{Microsoft.AspNetCore.Http.HttpContext,System.Boolean},System.String[])", new XmlComment(@"enable anti-forgery token verification middleware.
make sure to also add the anti-forgery services with `builder.Services.AddAntiForgery()`", null, null, null, null, false, null, [new XmlParameterComment(@"skipRequestFilter", @"an optional predicate which can be used to skip anti-forgery checks for requests that satisfy a given condition.
provide a function that returns `true` for requests that you'd want the anti-forgery middleware to skip processing.", null, false), new XmlParameterComment(@"additionalContentTypes", @"optional array of additional content-types to enforce antiforgery checks for (if the endpoint has enabled antiforgery).", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.Create``1(Microsoft.AspNetCore.Http.DefaultHttpContext,System.Object[])", new XmlComment(@"get an instance of an endpoint suitable for unit testing", null, null, null, null, false, null, [new XmlParameterComment(@"httpContext", @"a default http context object", null, false), new XmlParameterComment(@"ctorDependencies", @"the dependencies of the endpoint if it has any constructor injected dependencies", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.Create``1(System.Action{Microsoft.AspNetCore.Http.DefaultHttpContext},System.Object[])", new XmlComment(@"get an instance of an endpoint suitable for unit testing", null, null, null, null, false, null, [new XmlParameterComment(@"httpContext", @"an action for configuring the default http context object", null, false), new XmlParameterComment(@"ctorDependencies", @"the dependencies of the endpoint if it has any constructor injected arguments", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.Create``1(System.Object[])", new XmlComment(@"get an instance of an endpoint suitable for unit testing", null, null, null, null, false, null, [new XmlParameterComment(@"ctorDependencies", @"the dependencies of the endpoint if it has any constructor injected dependencies", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.AddServicesForUnitTesting(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(@"adds the minimum required set of services for unit testing FE endpoints", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Factory.AddTestServices(Microsoft.AspNetCore.Http.HttpContext,System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})", new XmlComment(@"register fake/mock/test services for the http context. typically only used with unit tests with the `Factory.Create()` method/&gt;", null, null, null, null, false, null, [new XmlParameterComment(@"s", @"an action for adding services to the IServiceCollection", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.RegisterTestServices(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})", new XmlComment(@"register fake/mock/test services for the current test execution context.", null, null, null, null, false, null, [new XmlParameterComment(@"s", @"an action for adding services to the IServiceCollection", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.CreateValidator``1(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})", new XmlComment(@"get an instance of a validator that uses Resolve&lt;T&gt;() methods to obtain services registered in the DI container.", null, null, null, null, false, null, [new XmlParameterComment(@"s", @"an action for adding services to the IServiceCollection", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.CreateMapper``1(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})", new XmlComment(@"get an instance of a mapper that uses Resolve&lt;T&gt;() methods to obtain services registered in the DI container.", null, null, null, null, false, null, [new XmlParameterComment(@"s", @"an action for adding services to the IServiceCollection", null, false)], null));
            cache.Add(@"M:FastEndpoints.Factory.CreateEvent``1(System.Collections.Generic.IEnumerable{FastEndpoints.IEventHandler{``0}},System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})", new XmlComment(@"get an instance of an event suitable for unit testing.", null, null, null, null, false, null, [new XmlParameterComment(@"handlers", @"the fake/mock event handlers to register for this event", null, false), new XmlParameterComment(@"s", @"an optional action for adding services to the IServiceCollection", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.POSTAsync``2(System.Net.Http.HttpClient,System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.POSTAsync``3(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.POSTAsync``2(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.POSTAsync``2(System.Net.Http.HttpClient)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PATCHAsync``2(System.Net.Http.HttpClient,System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PATCHAsync``3(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PATCHAsync``2(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PATCHAsync``2(System.Net.Http.HttpClient)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PUTAsync``2(System.Net.Http.HttpClient,System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PUTAsync``3(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PUTAsync``2(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.PUTAsync``2(System.Net.Http.HttpClient)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.GETAsync``2(System.Net.Http.HttpClient,System.String,``0,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.GETAsync``3(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.GETAsync``2(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.GETAsync``2(System.Net.Http.HttpClient)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.DELETEAsync``2(System.Net.Http.HttpClient,System.String,``0,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.DELETEAsync``3(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.DELETEAsync``2(System.Net.Http.HttpClient,``1,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.DELETEAsync``2(System.Net.Http.HttpClient)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.SENDAsync``2(System.Net.Http.HttpClient,System.Net.Http.HttpMethod,System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.POSTAsync``2(System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a POST request using a request dto and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as well
as the TResponse DTO/&gt;.", null, null, null, null, false, null, [new XmlParameterComment(@"requestUri", @"the route url to post to", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.POSTAsync``3(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a POST request to an endpoint using auto route discovery using a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.POSTAsync``2(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a POST request to an endpoint using auto route discovery using a request dto that does not send back a response dto.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.POSTAsync``2", new XmlComment(@"make a POST request to an endpoint using auto route discovery without a request dto and get back a TestResult&lt;TResponse&gt; containing
the HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PATCHAsync``2(System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PATCH request using a request dto and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as
well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"requestUri", @"the route url to PATCH to", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PATCHAsync``3(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PATCH request to an endpoint using auto route discovery using a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to true, headers will be automatically added to the http request from request dto properties decorated with the [FromHeader] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PATCHAsync``2(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PATCH request to an endpoint using auto route discovery using a request dto that does not send back a response dto.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PATCHAsync``2", new XmlComment(@"make a PATCH request to an endpoint using auto route discovery without a request dto and get back a TestResult&lt;TResponse&gt; containing
the HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PUTAsync``2(System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PUT request using a request dto and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as well
as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"requestUri", @"the route url to post to", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PUTAsync``3(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PUT request to an endpoint using auto route discovery using a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PUTAsync``2(``1,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"make a PUT request to an endpoint using auto route discovery using a request dto that does not send back a response dto.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.PUTAsync``2", new XmlComment(@"make a PUT request to an endpoint using auto route discovery without a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.GETAsync``2(System.String,``0,System.Boolean,System.Boolean)", new XmlComment(@"make a GET request using a request dto and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as well
as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"requestUri", @"the route url to post to", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.GETAsync``3(``1,System.Boolean,System.Boolean)", new XmlComment(@"make a GET request to an endpoint using auto route discovery using a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.GETAsync``2(``1,System.Boolean,System.Boolean)", new XmlComment(@"make a GET request to an endpoint using auto route discovery using a request dto that does not send back a response dto.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.GETAsync``2", new XmlComment(@"make a GET request to an endpoint using auto route discovery without a request dto and get back a TestResult&lt;TResponse&gt; containing the
HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.DELETEAsync``2(System.String,``0,System.Boolean,System.Boolean)", new XmlComment(@"make a DELETE request using a request dto and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as
well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"requestUri", @"the route url to post to", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.DELETEAsync``3(``1,System.Boolean,System.Boolean)", new XmlComment(@"make a DELETE request to an endpoint using auto route discovery using a request dto and get back a TestResult&lt;TResponse&gt; containing
the HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.DELETEAsync``2(``1,System.Boolean,System.Boolean)", new XmlComment(@"make a DELETE request to an endpoint using auto route discovery using a request dto that does not send back a response dto.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.DELETEAsync``2", new XmlComment(@"make a DELETE request to an endpoint using auto route discovery without a request dto and get back a TestResult&lt;TResponse&gt; containing
the HttpResponseMessage as well as the TResponse DTO.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HttpClientExtensions.<G>$2C76DB3DB4BE8E5FC629D93AC0513B6F.SENDAsync``2(System.Net.Http.HttpMethod,System.String,``0,System.Boolean,System.Boolean,System.Boolean)", new XmlComment(@"send a request DTO to a given endpoint URL and get back a TestResult&lt;TResponse&gt; containing the HttpResponseMessage as
well as the TResponse DTO", null, null, null, null, false, null, [new XmlParameterComment(@"method", @"the http method to use", null, false), new XmlParameterComment(@"requestUri", @"the route url of the endpoint", null, false), new XmlParameterComment(@"request", @"the request dto", null, false), new XmlParameterComment(@"sendAsFormData", @"when set to true, the request dto will be automatically converted to a MultipartFormDataContent", null, false), new XmlParameterComment(@"populateHeaders", @"when set to false, headers will not be automatically added to the http request from request dto properties decorated with the
[FromHeader] attribute.", null, false), new XmlParameterComment(@"populateCookies", @"when set to false, cookies will not be automatically added to the http request from request dto properties decorated with the
[FromCookie] attribute.", null, false)], null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.RegisterTestCommandHandler``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.RegisterTestCommandHandler``3(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.RegisterTestEventHandler``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.RegisterTestEventReceivers(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.RegisterTestCommandReceivers(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.GetTestEventReceiver``1(System.IServiceProvider)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.GetTestCommandReceiver``1(System.IServiceProvider)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$7B30185E57B8298C6754F16C0BCF4773.RegisterTestCommandHandler``2", new XmlComment(@"register test/fake/mock command handlers for integration testing commands that don't return a result", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$7B30185E57B8298C6754F16C0BCF4773.RegisterTestCommandHandler``3", new XmlComment(@"register test/fake/mock command handlers for integration testing commands that returns a result", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$7B30185E57B8298C6754F16C0BCF4773.RegisterTestEventHandler``2", new XmlComment(@"register test/fake/mock event handlers for integration testing events", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$7B30185E57B8298C6754F16C0BCF4773.RegisterTestEventReceivers", new XmlComment(@"registers test event receivers for the purpose of testing receipt of events.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$7B30185E57B8298C6754F16C0BCF4773.RegisterTestCommandReceivers", new XmlComment(@"registers test command receivers for the purpose of testing receipt of commands.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$AEA33270220B6BEE5910F5E99F6B03EE.GetTestEventReceiver``1", new XmlComment(@"gets a test event receiver for a given event type.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.TestingExtensions.<G>$AEA33270220B6BEE5910F5E99F6B03EE.GetTestCommandReceiver``1", new XmlComment(@"gets a test command receiver for a given command type.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.TestResult`1", new XmlComment(@"a record encapsulating the http response as well as the resulting dto of a test execution", null, null, null, null, false, null, [new XmlParameterComment(@"Response", @"http response message object", null, false), new XmlParameterComment(@"Result", @"the resulting dto object", null, false)], null));
            cache.Add(@"M:FastEndpoints.TestResult`1.#ctor(System.Net.Http.HttpResponseMessage,`0)", new XmlComment(@"a record encapsulating the http response as well as the resulting dto of a test execution", null, null, null, null, false, null, [new XmlParameterComment(@"Response", @"http response message object", null, false), new XmlParameterComment(@"Result", @"the resulting dto object", null, false)], null));
            cache.Add(@"P:FastEndpoints.TestResult`1.Response", new XmlComment(@"http response message object", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.TestResult`1.Result", new XmlComment(@"the resulting dto object", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IValidationErrors.ValidationFailures", new XmlComment(@"validation failures collection for the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IValidationErrors.ValidationFailed", new XmlComment(@"indicates if there are any validation failures for the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.AddError(FluentValidation.Results.ValidationFailure)", new XmlComment(@"add a ValidationFailure to the current collection of validation failures of the endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"failure", @"the validation failure to add", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.AddError(System.String,System.String,FluentValidation.Severity)", new XmlComment(@"adds a ""GeneralError"" to the current list of validation failures", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.ThrowIfAnyErrors(System.Nullable{System.Int32})", new XmlComment(@"interrupt the flow of handler execution and send a 400 bad request with error details if there are any validation failures in the current request. if
there are no validation failures, execution will continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.ThrowError(FluentValidation.Results.ValidationFailure,System.Nullable{System.Int32})", new XmlComment(@"adds a ValidationFailure to the validation failure collection of the endpoint and send back a 400 bad request with error details
immediately interrupting handler execution flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"failure", @"the validation failure to add", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.ThrowError(System.String,System.Nullable{System.Int32})", new XmlComment(@"adds a ""GeneralError"" to the validation failure list and sends back a 400 bad request with error details immediately interrupting handler execution
flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors.ThrowError(System.String,System.String,FluentValidation.Severity,System.Nullable{System.Int32})", new XmlComment(@"adds a ""GeneralError"" to the validation failure list and sends back a 400 bad request with error details immediately interrupting handler execution
flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors`1.AddError(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,FluentValidation.Severity)", new XmlComment(@"adds an error message for the specified property of the request dto", null, null, null, null, false, null, [new XmlParameterComment(@"property", @"the property to add the error message for", null, false), new XmlParameterComment(@"errorMessage", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors`1.ThrowError(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{System.Int32})", new XmlComment(@"adds an error message for the specified property of the request dto and sends back a 400 bad request with error details immediately interrupting
handler execution flow. no execution will continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"property", @"the property to add the error message for", null, false), new XmlParameterComment(@"errorMessage", @"the error message", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.IValidationErrors`1.ThrowError(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,FluentValidation.Severity,System.Nullable{System.Int32})", new XmlComment(@"adds an error message for the specified property of the request dto and sends back a 400 bad request with error details immediately interrupting
handler execution flow. no execution will continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"property", @"the property to add the error message for", null, false), new XmlParameterComment(@"errorMessage", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"T:FastEndpoints.ValidationContext", new XmlComment(@"provides a way to manipulate the validation failures of the current endpoint context.
call ValidationContext ValidationContext.Instance to obtain an instance of the current validation context.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationContext.Instance", new XmlComment(@"provides access to the validation context of the currently executing endpoint.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationContext.ValidationFailures", new XmlComment(@"validation failures collection for the endpoint", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationContext.ValidationFailed", new XmlComment(@"indicates if there are any validation failures for the current request", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ValidationContext.AddError(FluentValidation.Results.ValidationFailure)", new XmlComment(@"add a ValidationFailure to the current collection of validation failures of the endpoint", null, null, null, null, false, null, [new XmlParameterComment(@"failure", @"the validation failure to add", null, false)], null));
            cache.Add(@"M:FastEndpoints.ValidationContext.AddError(System.String,System.String,FluentValidation.Severity)", new XmlComment(@"adds a ""GeneralError"" to the current list of validation failures", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false)], null));
            cache.Add(@"M:FastEndpoints.ValidationContext.ThrowError(FluentValidation.Results.ValidationFailure,System.Nullable{System.Int32})", new XmlComment(@"adds a ValidationFailure to the validation failure collection of the endpoint and send back a 400 bad request with error details
immediately interrupting handler execution flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"failure", @"the validation failure to add", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.ValidationContext.ThrowError(System.String,System.Nullable{System.Int32})", new XmlComment(@"adds a ""GeneralError"" to the validation failure list and sends back a 400 bad request with error details immediately interrupting handler execution
flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.ValidationContext.ThrowError(System.String,System.String,FluentValidation.Severity,System.Nullable{System.Int32})", new XmlComment(@"adds a ""GeneralError"" to the validation failure list and sends back a 400 bad request with error details immediately interrupting handler execution
flow. i.e. execution will not continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"message", @"the error message", null, false), new XmlParameterComment(@"errorCode", @"the error code associated with the error", null, false), new XmlParameterComment(@"severity", @"the severity of the error", null, false), new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"M:FastEndpoints.ValidationContext.ThrowIfAnyErrors(System.Nullable{System.Int32})", new XmlComment(@"interrupt the flow of handler execution and send a 400 bad request with error details if there are any validation failures in the current request. if
there are no validation failures, execution will continue past this call.", null, null, null, null, false, null, [new XmlParameterComment(@"statusCode", @"an optional status code to be used when building the error response", null, false)], null));
            cache.Add(@"T:FastEndpoints.ValidationFailureException", new XmlComment(@"the exception thrown when validation failure occurs.
inspect the `Failures` property for details.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationFailureException.Failures", new XmlComment(@"the collection of failures that have occured.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.ValidationFailureException.StatusCode", new XmlComment(@"the status code to be used when building the error response.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Validator`1", new XmlComment(@"            inherit from this base class to define your dto validators
            HINT: validators are registered as singletons. i.e. the same validator instance is used to validate each request for best performance. hance,
do not maintain state in your validators.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.TryResolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.TryResolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.Resolve``1", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.Resolve(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.CreateScope", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.TryResolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.TryResolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.Resolve``1(System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Validator`1.Resolve(System.Type,System.String)", new XmlComment(null, null, null, null, null, false, null, null, null));

            cache.Add(@"T:FastEndpoints.IJobStorageProvider`1", new XmlComment(@"interface for defining the contract of a job storage provider", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.StoreJobAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"store the job storage record however you please. ideally on a nosql database.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the job storage record which contains the actual command object as well as some metadata", null, false), new XmlParameterComment(@"ct", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.GetNextBatchAsync(FastEndpoints.PendingJobSearchParams{`0})", new XmlComment(@"fetch the next pending batch of job storage records that need to be processed, with the supplied search parameters.", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find the next batch of job records from your database", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.MarkJobAsCompleteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"mark the job storage record as complete by either replacing the entity on storage with the supplied instance or
simply update the bool IJobStorageRecord.IsComplete field to true with a partial update operation.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the job storage record to mark as complete", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.CancelJobAsync(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"either delete the job storage record from the db using the supplied tracking id or update the bool IJobStorageRecord.IsComplete field to true
with a partial update operation.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the Guid IJobStorageRecord.TrackingID of the job to be cancelled", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.OnHandlerExecutionFailureAsync(`0,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"            this will only be triggered when a command handler (ICommandHandler&lt;TCommand&gt;) associated with a command
            throws an exception. If you've set an execution time limit for the command, the thrown exception would be of type
            OperationCanceledException.
            when a job/command execution fails, it will be retried immediately. the failed job will be fetched again with the next batch of pending jobs.
if one or more jobs keep failing repeatedly, it may cause the whole queue to get stuck in a retry loop preventing it from progressing.to prevent this from happening and allow other jobs to be given a chance at execution, you can reschedule failed jobs
to be re-attempted at a future time instead. simply update the DateTime IJobStorageRecord.ExecuteAfter property to a future date/time
and save the entity to the database (or do a partial update of only that property value).", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the job that failed to execute successfully", null, false), new XmlParameterComment(@"exception", @"the exception that was thrown", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobStorageProvider`1.PurgeStaleJobsAsync(FastEndpoints.StaleJobSearchParams{`0})", new XmlComment(@"this method will be called hourly. implement this method to delete stale records (completed or expired) from storage.
you can safely delete the completed records. the incomplete &amp; expired records can be moved to some other location (dead-letter-queue maybe) or
for inspection by a human.
or if you'd like to retry expired events, update the DateTime IJobStorageRecord.ExpireOn field to a future date/time.", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find stale job records from your database", null, false)], null));
            cache.Add(@"T:FastEndpoints.IJobResultProvider", new XmlComment(@"addon interface to enable a job storage provider (IJobStorageProvider&lt;TStorageRecord&gt;) to support commands that return results.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobResultProvider.StoreJobResultAsync``1(System.Guid,``0,System.Threading.CancellationToken)", new XmlComment(@"lookup the job storage record by the supplied tracking id and update it's object? IJobResultStorage.Result property and persist to the database.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the Guid IJobStorageRecord.TrackingID of the job to be looked up", null, false), new XmlParameterComment(@"result", @"the job result to be stored", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobResultProvider.GetJobResultAsync``1(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"lookup the job storage record by the supplied tracking id and return its object? IJobResultStorage.Result value.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the Guid IJobStorageRecord.TrackingID of the job to be looked up", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IJobStorageRecord", new XmlComment(@"the contract for a job storage record entity", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.QueueID", new XmlComment(@"a unique id for the job queue. each command type has its own queue. this is automatically generated by the library.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.TrackingID", new XmlComment(@"a unique id used to track a particular job for the purpose of progress monitoring and/or termination.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.Command", new XmlComment(@"            the actual command object that will be embedded in the storage record.
            if your database/orm (such as ef-core) doesn't support embedding objects, you can take the following steps:
            ```1. add a [NotMapped] attribute to this property.
2. add a new property, either a string or byte[]
3. implement both GetCommand() and SetCommand() methods to serialize/deserialize the command object back and forth and store it in the newly added property.```
            you may use any serializer you please. recommendation is to use MessagePack.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.ExecuteAfter", new XmlComment(@"the job will not be executed before this date/time. by default, it will automatically be set to the time of creation allowing jobs to be executed as soon as they're
created.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.ExpireOn", new XmlComment(@"the expiration date/time of job. if the job remains in an incomplete state past this time, the record is considered stale, and will be marked for removal from
storage.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobStorageRecord.IsComplete", new XmlComment(@"indicates whether the job has successfully completed or not.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobStorageRecord.GetCommand``1", new XmlComment(@"implement this function to customize command deserialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobStorageRecord.SetCommand``1(``0)", new XmlComment(@"implement this method to customize command serialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IJobResultStorage", new XmlComment(@"addon interface to enable storage of job results on a job storage record (IJobStorageRecord)", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IJobResultStorage.Result", new XmlComment(@"            the actual result object that will be embedded in the storage record.
            if your database/orm (such as ef-core) doesn't support embedding objects, you can take the following steps:
            ```1. add a [NotMapped] attribute to this property.
2. add a new property, either a string or byte[]
3. implement both GetResult() and SetResult() methods to serialize/deserialize the command object back and forth and store it in the newly added property.```
            you may use any serializer you please. recommendation is to use MessagePack.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobResultStorage.GetResult``1", new XmlComment(@"implement this function to customize the result deserialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobResultStorage.SetResult``1(``0)", new XmlComment(@"implement this method to customize the result serialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IHasCommandType", new XmlComment(@"implement this interface on your job storage record if you'd like to persist the full type name of the command class which is associated with the storage record.
you don't need to set the value yourself as it will be automatically set by the system.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IHasCommandType.CommandType", new XmlComment(@"the full type name of the command", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.AddJobQueues``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Reflection.Assembly[])", new XmlComment(@"add job queue functionality", null, null, null, null, false, null, [new XmlParameterComment(@"svc", @"", null, false), new XmlParameterComment(@"assemblies", @"assemblies to scan for command handlers, in addition to all loaded assemblies.
only applicable when using job queues as a standalone library.", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.UseJobQueues(Microsoft.Extensions.Hosting.IHost,System.Action{FastEndpoints.JobQueueOptions})", new XmlComment(@"enable job queue functionality with given settings", null, null, null, null, false, null, [new XmlParameterComment(@"app", @"", null, false), new XmlParameterComment(@"options", @"specify settings/execution limits for each job queue type", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.UseJobQueues(System.IServiceProvider,System.Action{FastEndpoints.JobQueueOptions})", new XmlComment(@"enable job queue functionality with given settings", null, null, null, null, false, null, [new XmlParameterComment(@"provider", @"", null, false), new XmlParameterComment(@"options", @"specify settings/execution limits for each job queue type", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.CreateJob``1(FastEndpoints.ICommandBase,System.Nullable{System.DateTime},System.Nullable{System.DateTime})", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.TriggerJobExecution(FastEndpoints.ICommandBase)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.TriggerJobExecution``1", new XmlComment(@"triggers the execution of jobs in the respective queue for that command type.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.QueueJobAsync(FastEndpoints.ICommandBase,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Threading.CancellationToken)", new XmlComment(@"queues up a given command in the respective job queue for that command type.", null, null, null, null, false, null, [new XmlParameterComment(@"cmd", @"the command to be queued", null, false), new XmlParameterComment(@"executeAfter", @"if set, the job won't be executed before this date/time. if unspecified, execution is attempted as soon as possible.", null, false), new XmlParameterComment(@"expireOn", @"if set, job will be considered stale/expired after this date/time. if unspecified, jobs expire after 4 hours of creation.", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.JobQueueExtensions.<G>$19B08B1F2A4B5EB1E86A0FB492452F60.<M>$858D44F1A1729022B102A0084227D900", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"cmd", @"the command to be set in the job", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.<G>$19B08B1F2A4B5EB1E86A0FB492452F60.CreateJob``1(System.Nullable{System.DateTime},System.Nullable{System.DateTime})", new XmlComment(@"creates a new job object for the provided command.", null, null, @"the new job object", null, false, null, [new XmlParameterComment(@"executeAfter", @"if set, the job won't be executed before this date/time. if unspecified, execution is attempted as soon as possible.", null, false), new XmlParameterComment(@"expireOn", @"if set, job will be considered stale/expired after this date/time. if unspecified, jobs expire after 4 hours of creation.", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobQueueExtensions.<G>$19B08B1F2A4B5EB1E86A0FB492452F60.TriggerJobExecution", new XmlComment(@"triggers the execution of jobs in the respective queue for that command type.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.JobQueueOptions", new XmlComment(@"options for job queues", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobQueueOptions.MaxConcurrency", new XmlComment(@"the default max concurrency per job type. default value is the number of logical processors of the computer.
you can specify per queue type overrides using void JobQueueOptions.LimitsFor&lt;TCommand&gt;(int maxConcurrency, TimeSpan timeLimit)", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobQueueOptions.StorageProbeDelay", new XmlComment(@"specifies the interval for periodic re-checks of the storage to detect any scheduled jobs. these checks ensure that re-scheduled jobs are promptly executed.
the default interval is set to 60 seconds. a shorter delay will make re-scheduled jobs run faster but will increase the overall load on the storage system,
due to too frequent queries being issued. only reduce this delay if you need re-scheduled jobs re-execute faster.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobQueueOptions.ExecutionTimeLimit", new XmlComment(@"the per job type max execution time limit for handler executions unless otherwise overridden using void JobQueueOptions.LimitsFor&lt;TCommand&gt;(int maxConcurrency, TimeSpan timeLimit)
defaults to int Timeout.Infinite.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobQueueOptions.LimitsFor``1(System.Int32,System.TimeSpan)", new XmlComment(@"specify execution limits such a max concurrency and execution time limit for a given command type.", null, null, null, null, false, null, [new XmlParameterComment(@"maxConcurrency", @"the maximum number of command executions of the same command type that's allowed to execute at the same time", null, false), new XmlParameterComment(@"timeLimit", @"the maximum amount of time each command is allowed to execute for.
when execution time exceeds this value, a OperationCanceledException will be thrown.
when that happens you can handle it in the
Task IJobStorageProvider&lt;TStorageRecord&gt;.OnHandlerExecutionFailureAsync(TStorageRecord r, Exception exception, CancellationToken ct) method.", null, false)], null));
            cache.Add(@"T:FastEndpoints.JobResult`1", new XmlComment(@"a wrapper for holding a job execution result as well as any progress details.", null, null, null, null, false, null, [new XmlParameterComment(@"totalSteps", @"the total number of steps the job is expected to have", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobResult`1.#ctor(System.Int32)", new XmlComment(@"a wrapper for holding a job execution result as well as any progress details.", null, null, null, null, false, null, [new XmlParameterComment(@"totalSteps", @"the total number of steps the job is expected to have", null, false)], null));
            cache.Add(@"P:FastEndpoints.JobResult`1.CurrentStep", new XmlComment(@"the number of steps currently completed", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobResult`1.TotalSteps", new XmlComment(@"the number of total steps to be completed", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobResult`1.ProgressPercentage", new XmlComment(@"the percentage of steps currently completed", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobResult`1.CurrentStatus", new XmlComment(@"the current status", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobResult`1.Result", new XmlComment(@"the end result", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.JobResult`1.IsComplete", new XmlComment(@"returns true if either the result is ready or if all the steps are complete.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IJobTracker`1", new XmlComment(@"the interface defining a job tracker", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IJobTracker`1.CancelJobAsync(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"cancel a job by its tracking id. if the job is currently executing, the cancellation token passed down to the command handler method will be notified of the
cancellation. the job storage record will also be marked complete via Task IJobStorageProvider&lt;TStorageRecord&gt;.CancelJobAsync(Guid trackingId, CancellationToken ct) method of the job storage
provider, which will prevent the job from being picked up for execution.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobTracker`1.StoreJobResultAsync``1(System.Guid,``0,System.Threading.CancellationToken)", new XmlComment(@"this method can be used to either store a preliminary job result and/or job progress before the job execution fully completes.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"result", @"the preliminary job result or progress to store", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IJobTracker`1.GetJobResultAsync``1(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"retrieve the result of a command (that returns a result) which was previously queued as a job.
the returned result will be null/default until the job is actually complete.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.JobTracker`1", new XmlComment(@"a IJobTracker&lt;TCommand&gt; implementation used for tracking queued jobs", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.JobTracker`1.CancelJobAsync(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"cancel a job by its tracking id. if the job is currently executing, the cancellation token passed down to the command handler method will be notified of the
cancellation. the job storage record will also be marked complete via Task IJobStorageProvider&lt;TStorageRecord&gt;.CancelJobAsync(Guid trackingId, CancellationToken ct) method of the job storage
provider, which will prevent the job from being picked up for execution.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobTracker`1.StoreJobResultAsync``1(System.Guid,``0,System.Threading.CancellationToken)", new XmlComment(@"this method can be used to either store a preliminary job result and/or job progress before the job execution fully completes.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"result", @"the preliminary job result or progress to store", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.JobTracker`1.GetJobResultAsync``1(System.Guid,System.Threading.CancellationToken)", new XmlComment(@"retrieve the result of a command (that returns a result) which was previously queued as a job.
the returned result will be null/default until the job is actually complete.", null, null, null, null, false, null, [new XmlParameterComment(@"trackingId", @"the job tracking id", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.PendingJobSearchParams`1", new XmlComment(@"a dto representing search parameters for pending job storage record retrieval.
Note: This is a class (not struct) for Native AOT compatibility.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingJobSearchParams`1.QueueID", new XmlComment(@"the ID of the job queue for fetching the next batch of records for.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingJobSearchParams`1.Match", new XmlComment(@"       a boolean lambda expression to match the next batch of records
       ```r =&gt; r.QueueID == ""xxx"" &amp;&amp;
!r.IsComplete &amp;&amp;
DateTime.UtcNow &gt;= r.ExecuteAfter &amp;&amp;
DateTime.UtcNow &lt;= r.ExpireOn```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingJobSearchParams`1.Limit", new XmlComment(@"the number of pending records to fetch", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingJobSearchParams`1.CancellationToken", new XmlComment(@"cancellation token", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.StaleJobSearchParams`1", new XmlComment(@"a dto representing search parameters for matching stale job storage records", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StaleJobSearchParams`1.Match", new XmlComment(@"a boolean lambda expression to match stale job records
```r =&gt; r.IsComplete || r.ExpireOn &lt;= DateTime.UtcNow```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StaleJobSearchParams`1.CancellationToken", new XmlComment(@"cancellation token", null, null, null, null, false, null, null, null));

            cache.Add(@"T:FastEndpoints.Void", new XmlComment(@"", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IJobResult", new XmlComment(@"", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommandBase", new XmlComment(@"common marker interface for all command types.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommand", new XmlComment(@"interface for a command that does not return anything", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommand`1", new XmlComment(@"interface for a command that returns a TResult", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IHasTrackingID", new XmlComment(@"", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IHasTrackingID.TrackingID", new XmlComment(@"tracking id of the job", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ITrackableJob`1", new XmlComment(@"interface for a trackable job that returns a TResult", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IServerStreamCommand`1", new XmlComment(@"interface for a command that returns a stream of TResult", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommandHandler", new XmlComment(@"marker interface for all command handlers", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommandHandler`1", new XmlComment(@"interface to be implemented by a command handler for a given command type that does not return a result", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ICommandHandler`1.ExecuteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"accepts a command and does not return a result.", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the input command object", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.ICommandHandler`2", new XmlComment(@"interface to be implemented by a command handler for a given command type that returns a result", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ICommandHandler`2.ExecuteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"receives a command and returns a result.", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the input command object", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IServerStreamCommandHandler`2", new XmlComment(@"interface to be implemented by a command handler for a given command type that returns TResult stream", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IServerStreamCommandHandler`2.ExecuteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"receives a command and returns a stream of TResult.", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the input command object", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IClientStreamCommandHandler`2", new XmlComment(@"interface to be implemented by a command handler for a stream of T that returns a single TResult.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IClientStreamCommandHandler`2.ExecuteAsync(System.Collections.Generic.IAsyncEnumerable{`0},System.Threading.CancellationToken)", new XmlComment(@"accepts a stream of T and returns a TResult when the stream ends.", null, null, null, null, false, null, [new XmlParameterComment(@"stream", @"the stream of incoming items", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.ICommandReceiver`1", new XmlComment(@"interface for a command receiver that can be used to test the receipt of commands in testing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ICommandReceiver`1.WaitForMatchAsync(System.Func{`0,System.Boolean},System.Int32,System.Threading.CancellationToken)", new XmlComment(@"waits until at least one matching command is received not exceeding the timeout period.", null, null, null, null, false, null, [new XmlParameterComment(@"match", @"a predicate for matching commands that should be returned by the method", null, false), new XmlParameterComment(@"timeoutSeconds", @"how long the method will wait until a matching command is received. default value is 2 seconds", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.CommandReceiver`1", new XmlComment(@"the default implementation of a command receiver that can be used to test the execution of a command.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandReceiver`1.WaitForMatchAsync(System.Func{`0,System.Boolean},System.Int32,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEvent", new XmlComment(@"marker interface for an event model", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEventHandler", new XmlComment(@"marker interface for all event handlers", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEventHandler`1", new XmlComment(@"interface to be implemented by event handlers", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventHandler`1.HandleAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"the handler logic for the event handler", null, null, null, null, false, null, [new XmlParameterComment(@"eventModel", @"the input event model", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.IEventReceiver`1", new XmlComment(@"interface for an event receiver that can be used to test the receipt of events in testing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventReceiver`1.WaitForMatchAsync(System.Func{`0,System.Boolean},System.Int32,System.Threading.CancellationToken)", new XmlComment(@"waits until at least one matching event is received not exceeding the timeout period.", null, null, null, null, false, null, [new XmlParameterComment(@"match", @"a predicate for matching events that should be returned by the method", null, false), new XmlParameterComment(@"timeoutSeconds", @"how long the method will wait until a matching event is received. default value is 2 seconds", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.EventReceiver`1", new XmlComment(@"the default implementation of an event receiver that can be used to test the execution of and event.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EventReceiver`1.WaitForMatchAsync(System.Func{`0,System.Boolean},System.Int32,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));

            cache.Add(@"T:FastEndpoints.CommandHandlerRegistry", new XmlComment(@"registry for command handlers. maps command types to their handler definitions.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.ExecuteAsync``1(``0,System.Threading.CancellationToken)", new XmlComment(@"executes the command that does not return a result", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the command to execute", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.ExecuteAsync``1(FastEndpoints.ICommand{``0},System.Threading.CancellationToken)", new XmlComment(@"executes the command and returns a result", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the command to execute", null, false), new XmlParameterComment(@"ct", @"optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.RegisterForTesting``1(FastEndpoints.ICommandHandler{``0,FastEndpoints.Void})", new XmlComment(@"registers a fake command handler for unit testing purposes", null, null, null, null, false, null, [new XmlParameterComment(@"handler", @"a fake handler instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.RegisterForTesting``2(FastEndpoints.ICommandHandler{``0,``1})", new XmlComment(@"registers a fake command handler for unit testing purposes", null, null, null, null, false, null, [new XmlParameterComment(@"handler", @"a fake handler instance", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.RegisterGenericCommand``2(System.IServiceProvider)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.RegisterGenericCommand(System.IServiceProvider,System.Type,System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.AddCommandMiddleware(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FastEndpoints.CommandMiddlewareConfig})", new XmlComment(@"register a common middleware pipeline for command handlers. the middleware can be created as open generic classes that implement the
ICommandMiddleware&lt;TCommand, TResult&gt; interface as well as closed generic classes implementing the same interface.", null, null, @"the service collection for chaining", null, false, null, [new XmlParameterComment(@"services", @"the service collection", null, false), new XmlParameterComment(@"config", @"configuration action for adding middleware components to the pipeline", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.EnableAotMode", new XmlComment(@"enables AOT mode for command execution, requiring all executors to be pre-generated.
when enabled, MakeGenericType will not be used and an exception will be thrown if a pre-generated executor is not found.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.RegisterCommandExecutors(System.IServiceProvider,System.Action{FastEndpoints.CommandHandlerRegistry,System.IServiceProvider})", new XmlComment(@"Registers pre-generated command handler executors with the command registry.
This method should be called at application startup with a delegate that calls the source-generated RegisterCommandExecutors method.", null, null, null, null, false, [@"    ```// In Program.cs after app.UseFastEndpoints():
app.RegisterCommandExecutors((registry, sp) =&gt; GeneratedReflection.RegisterCommandExecutors(registry, sp));
CommandExtensions.EnableAotMode(); // Optional: require all commands to use pre-generated executors```"], [new XmlParameterComment(@"sp", @"The service provider to resolve middleware dependencies.", null, false), new XmlParameterComment(@"registrationAction", @"A delegate that receives the registry and service provider. 
Typically this calls the source-generated GeneratedReflection.RegisterCommandExecutors method.", null, false)], null));
            cache.Add(@"T:FastEndpoints.CommandExtensions.<G>$AEA33270220B6BEE5910F5E99F6B03EE.<M>$11645D5D304D9724C1AB01093815E01A", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"sp", @"the service provider", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.<G>$AEA33270220B6BEE5910F5E99F6B03EE.RegisterGenericCommand``2", new XmlComment(@"register a generic command handler for a generic command", null, null, @"the service provider for chaining", null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandExtensions.<G>$AEA33270220B6BEE5910F5E99F6B03EE.RegisterGenericCommand(System.Type,System.Type)", new XmlComment(@"register a generic command handler for a generic command", null, null, @"the service provider for chaining", null, false, null, [new XmlParameterComment(@"genericCommandType", @"the open generic type of the command. ex: `typeof(MyCommand&lt;&gt;)`", null, false), new XmlParameterComment(@"genericHandlerType", @"the open generic type of the command handler. ex: `typeof(MyCommandHandler&lt;,&gt;)`", null, false)], null));
            cache.Add(@"T:FastEndpoints.CommandHandlerDefinition", new XmlComment(@"definition for a command handler, containing the handler type and executor.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.CommandHandlerDefinition.HandlerType", new XmlComment(@"the type of the command handler.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.CommandHandlerDefinition.HandlerExecutor", new XmlComment(@"the cached executor instance for this command handler.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandHandlerDefinition.#ctor(System.Type)", new XmlComment(@"creates a new command handler definition for the specified handler type.", null, null, null, null, false, null, [new XmlParameterComment(@"handlerType", @"the type of the command handler", null, false)], null));
            cache.Add(@"T:FastEndpoints.ICommandHandlerExecutor`1", new XmlComment(@"interface for command handler executors that execute commands and return results.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ICommandHandlerExecutor`1.Execute(FastEndpoints.ICommand{`0},System.Type,System.Threading.CancellationToken)", new XmlComment(@"executes a command and returns the result.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.CommandHandlerExecutor`2", new XmlComment(@"executes a command handler with optional middleware pipeline.
this class is singleton and cached in CommandHandlerDefinition.HandlerExecutor.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandHandlerExecutor`2.#ctor(System.Collections.Generic.IEnumerable{FastEndpoints.ICommandMiddleware{`0,`1}},FastEndpoints.ICommandHandler{`0,`1},FastEndpoints.ICommandReceiver{`0})", new XmlComment(@"executes a command handler with optional middleware pipeline.
this class is singleton and cached in CommandHandlerDefinition.HandlerExecutor.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandHandlerExecutor`2.Execute(FastEndpoints.ICommand{`1},System.Type,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.CommandMiddlewareConfig", new XmlComment(@"command middleware configuration", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.CommandMiddlewareConfig.Register(System.Type[])", new XmlComment(@"register one or more open-generic command middleware pieces in the order you'd like them registered.
```c.Register(typeof(CommandLogger&lt;,&gt;), typeof(CommandValidator&lt;,&gt;));```", null, null, null, null, false, null, [new XmlParameterComment(@"middlewareTypes", @"the open-generic middleware types to add to the pipeline.", null, false)], null));
            cache.Add(@"M:FastEndpoints.CommandMiddlewareConfig.Register``3", new XmlComment(@"register a closed-generic command middleware in the pipeline.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommandMiddleware`2", new XmlComment(@"interface for creating a command middleware used to build a pipeline around command handlers.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.ICommandMiddleware`2.ExecuteAsync(`0,FastEndpoints.CommandDelegate{`1},System.Threading.CancellationToken)", new XmlComment(@"implement this method to run some common piece of logic for all command handlers.
make sure to execute the next delegate within your logic in order to not break the pipeline.", null, null, null, null, false, null, [new XmlParameterComment(@"command", @"the command instance", null, false), new XmlParameterComment(@"next", @"the command delegate to execute next", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.CommandDelegate`1", new XmlComment(@"command delegate", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EventBase", new XmlComment(@"base class for the event bus", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EventBus`1", new XmlComment(@"event notification bus which uses an in-process pub/sub messaging system", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EventBus`1.#ctor(System.Collections.Generic.IEnumerable{FastEndpoints.IEventHandler{`0}},FastEndpoints.IEventReceiver{`0})", new XmlComment(@"instantiates an event bus for the given event dto type.", null, null, null, null, false, null, [new XmlParameterComment(@"eventHandlers", @"a collection of concrete event handler implementations that should receive notifications from this event bus", null, false), new XmlParameterComment(@"testEventReceiver", @"a test event receiver that can be used to assert receipt of events", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventBus`1.PublishAsync(`0,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publish the given model/dto to all the subscribers of the event notification", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventBus`1.PublishFilteredAsync(`0,System.Func{System.Type,System.Boolean},FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publish the given model/dto to a subset of the subscribers of the event notification", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"handlerFilter", @"a predicate for selecting which of the registered event handlers should be executed. if the predicate returns `false` for a particular event
handler, that handler will not be executed during the invocation.", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventExtensions.PublishAsync``1(``0,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publish the event to all subscribers registered to handle this type of event.", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventExtensions.PublishAsync(FastEndpoints.IEvent,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publish the event to all subscribers registered to handle this type of event.", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventExtensions.PublishFilteredAsync``1(``0,System.Func{System.Type,System.Boolean},FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publish the event to a subset of the subscribers registered to handle this type of event.", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"handlerFilter", @"a predicate for selecting which of the registered event handlers should be executed. if the predicate returns `false` for a particular event
handler, that handler will not be executed during the invocation.", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventPublisherRegistry.RegisterGeneratedPublishers(System.Func{System.Type,System.Func{FastEndpoints.IEvent,FastEndpoints.Mode,System.Threading.CancellationToken,System.Threading.Tasks.Task}})", new XmlComment(@"Registers the source-generated event publisher resolver.
This is called automatically by the generated EventPublishers class during app startup via module initializer.", null, null, null, null, false, null, [new XmlParameterComment(@"resolver", @"A function that returns a publish delegate for a given event type, or null if not found.", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventPublisherRegistry.PublishEvent``1(``0,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"Publishes an event using the EventBus. This method is used by generated code
to avoid calling EventExtensions directly (which has naming conflicts).", null, null, @"A task representing the publish operation.", null, false, null, [new XmlParameterComment(@"eventModel", @"The event to publish.", null, false), new XmlParameterComment(@"waitMode", @"The wait mode for subscribers.", null, false), new XmlParameterComment(@"cancellation", @"Cancellation token.", null, false)], null));
            cache.Add(@"T:FastEndpoints.IEventBus", new XmlComment(@"interface to be implemented by an event bus", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventBus.PublishAsync``1(``0,FastEndpoints.Mode,System.Threading.CancellationToken)", new XmlComment(@"publishes a given event model to all subscribers registered to handle the that type of event.", null, null, @"a Task that matches the wait mode specified.
Mode.WaitForNone returns an already completed Task (fire and forget).
Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work.
Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work.", null, false, null, [new XmlParameterComment(@"eventModel", @"the notification event model/dto to publish", null, false), new XmlParameterComment(@"waitMode", @"specify whether to wait for none, any or all of the subscribers to complete their work", null, false), new XmlParameterComment(@"cancellation", @"an optional cancellation token", null, false)], null));
            cache.Add(@"T:FastEndpoints.Mode", new XmlComment(@"enum for specifying the waiting mode for event notifications", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Mode.WaitForNone", new XmlComment(@"returns an already completed Task (fire and forget)
WARNING: exceptions cannot be captured by caller", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Mode.WaitForAny", new XmlComment(@"returns a Task that will complete when any of the subscribers complete their work
WARNING: exceptions cannot be captured by caller", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.Mode.WaitForAll", new XmlComment(@"return a Task that will complete only when all of the subscribers complete their work.
HINT: exceptions can be captured by caller", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.MessagingExtensions.AddMessaging(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Reflection.Assembly[])", new XmlComment(@"adds the messaging services (command bus and event bus) to the service collection.
TIP: You don't have to call this method if you already have .AddFastEndpoints() in your pipeline.", null, null, null, null, false, null, [new XmlParameterComment(@"services", @"", null, false), new XmlParameterComment(@"assemblies", @"assemblies to scan for command handlers and event handlers, in addition to all loaded assemblies.", null, false)], null));
            cache.Add(@"M:FastEndpoints.MessagingExtensions.UseMessaging(System.IServiceProvider)", new XmlComment(@"configures the messaging functionality.
TIP: You don't have to call this method if you already have .UseFastEndpoints() in your pipeline.", null, null, @"the service provider for chaining", null, false, null, [new XmlParameterComment(@"provider", @"the service provider", null, false)], null));

            cache.Add(@"T:FastEndpoints.IEventSubscriberStorageProvider`1", new XmlComment(@"interface for implementing a storage provider for an event subscription client app (gRPC client)", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventSubscriberStorageProvider`1.StoreEventAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"store the event storage record however you please. ideally on a nosql database.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the event storage record which contains the actual event object as well as some metadata", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventSubscriberStorageProvider`1.GetNextBatchAsync(FastEndpoints.PendingRecordSearchParams{`0})", new XmlComment(@"fetch the next batch of pending event storage records that need to be processed.", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find the next batch of event records from your database", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventSubscriberStorageProvider`1.MarkEventAsCompleteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"mark the event storage record as complete by either replacing the entity on storage with the supplied instance or
simply update the bool IEventStorageRecord.IsComplete field to true with a partial update operation.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the storage record to mark complete", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventSubscriberStorageProvider`1.PurgeStaleRecordsAsync(FastEndpoints.StaleRecordSearchParams{`0})", new XmlComment(@"            this method will be called hourly. implement this method to remove stale records (completed or expired) from storage.
            or instead of removing them, you can move them to some other location (dead-letter-queue maybe) or for inspection by a human.
            or if you'd like to retry expired events, update the DateTime IEventStorageRecord.ExpireOn field to a future date/time.
            NOTE: the default match criteria is:
```r =&gt; r.IsComplete || DateTime.UtcNow &gt;= r.ExpireOn```", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find stale records", null, false)], null));
            cache.Add(@"T:FastEndpoints.SubscriberExceptionReceiver", new XmlComment(@"inherit this class and override it's methods in order to receive event subscriber exceptions.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiver.OnStoreEventRecordError``1(FastEndpoints.IEventStorageRecord,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble persisting an event record.", null, null, null, null, false, null, [new XmlParameterComment(@"record", @"the event storage record that was supposed to be persisted", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the record was attempted to be persisted", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiver.OnEventReceiveError``1(System.String,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when there's an error reading the next event message from the underlying gRPC stream.
you'd hardly ever be overriding this method since it's none of your business most of the time and the operation would be
automatically retried until successful.", null, null, null, null, false, null, [new XmlParameterComment(@"subscriberID", @"the unique ID of the subscriber", null, false), new XmlParameterComment(@"attemptCount", @"the number unsuccessful attempts to read the event message", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiver.OnGetNextEventRecordError``1(System.String,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble retrieving the next event record.", null, null, null, null, false, null, [new XmlParameterComment(@"subscriberID", @"the unique ID of the subscriber", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the record was attempted to be retrieved", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiver.OnHandlerExecutionError``2(FastEndpoints.IEventStorageRecord,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the event handler has trouble executing the Task IEventHandler&lt;TEvent&gt;.HandleAsync(TEvent eventModel, CancellationToken ct) method.", null, null, null, null, false, null, [new XmlParameterComment(@"record", @"the event storage record that was supposed to be executed", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the record was attempted to be executed", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiver.OnMarkEventAsCompleteError``1(FastEndpoints.IEventStorageRecord,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble marking an event record as complete.", null, null, null, null, false, null, [new XmlParameterComment(@"record", @"the event storage record that was supposed to be marked complete", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the record was attempted to be marked complete", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.SubscriberExceptionReceiverExtensions.AddSubscriberExceptionReceiver``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(@"register a custom exception receiver for receiving event subscriber exceptions.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionCore", new XmlComment(@"represents a connection to a remote server that hosts command and event handlers", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.RemoteConnectionCore.ChannelOptions", new XmlComment(@"grpc channel settings", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.RemoteConnectionCore.RemoteAddress", new XmlComment(@"the address of the remote server", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.Register``1", new XmlComment(@"register a ""void"" command (ICommand) for this remote connection where the handler for it is hosted/located.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.Register``2", new XmlComment(@"register a ""unary"" command (ICommand&lt;TResult&gt;) for this remote connection where the handler for it is hosted/located.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.RegisterServerStream``2", new XmlComment(@"register a ""server stream"" command (IServerStreamCommand&lt;TResult&gt;) for this remote connection where the handler for it is hosted/located.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.RegisterClientStream``2", new XmlComment(@"register a remote handler for a ""client stream"" (IAsyncEnumerable&lt;T&gt;) for this remote connection.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.Subscribe``2(System.Threading.CancellationToken,System.String)", new XmlComment(@"subscribe to a broadcast channel for a given event type (TEvent) on the remote host.
the received events will be handled by the specified handler (TEventHandler) on this machine.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false), new XmlParameterComment(@"clientIdentifier", @"a unique identifier for this client. this will be used to create a durable subscriber id which will allow the server to
uniquely identify this subscriber/client across disconnections. if you don't set this value, only one subscriber from a single machine is possible.
i.e. if you spin up multiple instances of this subscriber they will all connect to the server with the same subscriber id, which will result in
unpredictable event receiving behavior.", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCore.Subscribe``2(Grpc.Core.CallOptions,System.String)", new XmlComment(@"subscribe to a broadcast channel for a given event type (TEvent) on the remote host.
the received events will be handled by the specified handler (TEventHandler) on this machine.", null, null, null, null, false, null, [new XmlParameterComment(@"callOptions", @"the call options", null, false), new XmlParameterComment(@"clientIdentifier", @"a unique identifier for this client. this will be used to create a durable subscriber id which will allow the server to
uniquely identify this subscriber/client across disconnections. if you don't set this value, only one subscriber from a single machine is possible.
i.e. if you spin up multiple instances of this subscriber they will all connect to the server with the same subscriber id, which will result in
unpredictable event receiving behavior.", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.MapRemoteCore(System.IServiceProvider,System.String,System.Action{FastEndpoints.RemoteConnectionCore})", new XmlComment(@"            creates a grpc channel/connection to a remote server that hosts a known collection of command handlers and event hubs.
            IMPORTANT: call the void RemoteConnectionCore.Register&lt;TCommand, TResult&gt;() method (using action r) to specify which commands are
handled by this remote server. event subscriptions can be specified using .Subscribe&lt;TEvent, TEventHandler&gt;() method.", null, null, null, null, false, null, [new XmlParameterComment(@"services", @"", null, false), new XmlParameterComment(@"remoteAddress", @"the address of the remote server", null, false), new XmlParameterComment(@"r", @"a configuration action for the connection", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync(FastEndpoints.ICommand,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync(FastEndpoints.ICommand,Grpc.Core.CallOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``1(FastEndpoints.ICommand{``0},System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``1(FastEndpoints.ICommand{``0},Grpc.Core.CallOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``1(FastEndpoints.IServerStreamCommand{``0},System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``1(FastEndpoints.IServerStreamCommand{``0},Grpc.Core.CallOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.RemoteExecuteAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},Grpc.Core.CallOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionCoreExtensions.<G>$CEA3D727D112530A24F6977E1CBFEC0F.<M>$6AFDC2AEFAF853AA77CB9359838C5254", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"command", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$CEA3D727D112530A24F6977E1CBFEC0F.RemoteExecuteAsync(System.Threading.CancellationToken)", new XmlComment(@"execute the command on the relevant remote server", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$CEA3D727D112530A24F6977E1CBFEC0F.RemoteExecuteAsync(Grpc.Core.CallOptions)", new XmlComment(@"execute the command on the relevant remote server", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"call options", null, false)], null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionCoreExtensions.<G>$D259B44FDC15A7F5E69246AA58ABCC97`1.<M>$0E34848E6AE982036F1B7C7D3183767A", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"command", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$D259B44FDC15A7F5E69246AA58ABCC97`1.RemoteExecuteAsync(System.Threading.CancellationToken)", new XmlComment(@"execute the command on the relevant remote server and get back a TResult result", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$D259B44FDC15A7F5E69246AA58ABCC97`1.RemoteExecuteAsync(Grpc.Core.CallOptions)", new XmlComment(@"execute the command on the relevant remote server and get back a TResult result", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"call options", null, false)], null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionCoreExtensions.<G>$C432DB21E38BDFDCFD82E83803BBBCAD`1.<M>$3BD1ACBE35EA92A08D4681DDFABB6393", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"command", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$C432DB21E38BDFDCFD82E83803BBBCAD`1.RemoteExecuteAsync(System.Threading.CancellationToken)", new XmlComment(@"execute the command on the relevant remote server and get back a stream of TResult", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$C432DB21E38BDFDCFD82E83803BBBCAD`1.RemoteExecuteAsync(Grpc.Core.CallOptions)", new XmlComment(@"execute the command on the relevant remote server and get back a stream of TResult", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"call options", null, false)], null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionCoreExtensions.<G>$10191C02F0C374185B47D5743E455DD5`1.<M>$67E9765C4C8C2FA03D6BECCF3C92D0B1", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"commands", @"the stream to send", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$10191C02F0C374185B47D5743E455DD5`1.RemoteExecuteAsync``1(System.Threading.CancellationToken)", new XmlComment(@"send the stream of TCommand commands to the relevant remote server and get back a result of TResult", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionCoreExtensions.<G>$10191C02F0C374185B47D5743E455DD5`1.RemoteExecuteAsync``1(Grpc.Core.CallOptions)", new XmlComment(@"send the stream of TCommand commands to the relevant remote server and get back a result of TResult", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"call options", null, false)], null));
            cache.Add(@"T:FastEndpoints.PendingRecordSearchParams`1", new XmlComment(@"a dto representing search parameters for pending event storage record retrieval", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingRecordSearchParams`1.SubscriberID", new XmlComment(@"the subscriber ID for fetching the next batch of records", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingRecordSearchParams`1.Match", new XmlComment(@"       a boolean lambda expression to match the next batch of records
       ```r =&gt; r.SubscriberID == ""xxx"" &amp;&amp;
!r.IsComplete &amp;&amp;
DateTime.UtcNow &lt;= r.ExpireOn```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingRecordSearchParams`1.Limit", new XmlComment(@"the number of pending records to fetch", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.PendingRecordSearchParams`1.CancellationToken", new XmlComment(@"cancellation token", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEventStorageRecord", new XmlComment(@"interface for implementing an event storage record that encapsulates/embeds an event (IEvent)", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IEventStorageRecord.SubscriberID", new XmlComment(@"a subscriber id is a unique identifier of an event stream subscriber on a remote node.
it is a unique id per each event handler type (TEvent+TEventHandler combo).
you don't have to worry about generating this as it will automatically be set by the library.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IEventStorageRecord.Event", new XmlComment(@"            the actual event object that will be embedded in the storage record.
            if your database/orm (such as ef-core) doesn't support embedding objects, you can take the following steps:
            ```1. add a [NotMapped] attribute to this property.
2. add a new property, either a `string` or byte array
3. implement both TEvent IEventStorageRecord.GetEvent&lt;TEvent&gt;() and void IEventStorageRecord.SetEvent&lt;TEvent&gt;(TEvent @event) to serialize/deserialize the event object back and forth and store it in the newly added property.```
            you may use any serializer you please. recommendation is to use MessagePack.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IEventStorageRecord.EventType", new XmlComment(@"the full type name of the event", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IEventStorageRecord.ExpireOn", new XmlComment(@"the expiration date/time of the event. this is used to purge stale records.
default value is 4 hours from time of creation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.IEventStorageRecord.IsComplete", new XmlComment(@"pending status of the event. will only return true if the event has been successfully processed and is ready to be discarded.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventStorageRecord.GetEvent``1", new XmlComment(@"implement this function to customize event deserialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventStorageRecord.SetEvent``1(``0)", new XmlComment(@"implement this method to customize event serialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.InMemoryEventQueue.MaxLimit", new XmlComment(@"the maximum number of items the internal queues are allowed to hold.
when the item count surpasses this limit, the queues will be in an overflow state preventing acceptance of new events.
NOTE: this limit applies per event type. i.e. if there's 10 event types, the total events held in memory will be 10X of this value.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.StaleRecordSearchParams`1", new XmlComment(@"a dto representing search parameters for matching stale event storage records", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StaleRecordSearchParams`1.Match", new XmlComment(@"a boolean lambda expression to match stale records
```r =&gt; r.IsComplete || DateTime.UtcNow &gt;= r.ExpireOn```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.StaleRecordSearchParams`1.CancellationToken", new XmlComment(@"cancellation token", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EmptyObject", new XmlComment(@"empty object class", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.ICommandExecutor", new XmlComment(@"marker interface for a command executor", null, null, null, null, false, null, null, null));

            cache.Add(@"T:FastEndpoints.RemoteConnection", new XmlComment(@"represents a connection to a remote server that hosts command and event handlers", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnection.RegisterEvent``1", new XmlComment(@"register an ""event"" that the remote server will be accepting (in HubMode.EventBroker) mode for distribution to subscribers.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.MapRemote(Microsoft.Extensions.Hosting.IHost,System.String,System.Action{FastEndpoints.RemoteConnection})", new XmlComment(@"            creates a grpc channel/connection to a remote server that hosts a known collection of command handlers and event hubs.
            IMPORTANT: call the void RemoteConnectionCore.Register&lt;TCommand, TResult&gt;() method (using action r) to specify which commands are
handled by this remote server. event subscriptions can be specified using app.Subscribe&lt;TEvent, TEventHandler&gt;() method.", null, null, null, null, false, null, [new XmlParameterComment(@"host", @"", null, false), new XmlParameterComment(@"remoteAddress", @"the address of the remote server", null, false), new XmlParameterComment(@"r", @"a configuration action for the connection", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.AddEventSubscriberStorageProvider``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(@"register a custom event subscriber storage provider", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.RemotePublishAsync(FastEndpoints.IEvent,System.Threading.CancellationToken)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.RemotePublishAsync(FastEndpoints.IEvent,Grpc.Core.CallOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.RemoteConnectionExtensions.<G>$8DBF87D1890CB028D0175A7D68DD8B33.<M>$BCD1702719EF1047603C41B4D8C0A9C1", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"evnt", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.<G>$8DBF87D1890CB028D0175A7D68DD8B33.RemotePublishAsync(System.Threading.CancellationToken)", new XmlComment(@"publish the event to the relevant remote server that's running in HubMode.EventBroker mode.", null, null, null, null, false, null, [new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.RemoteConnectionExtensions.<G>$8DBF87D1890CB028D0175A7D68DD8B33.RemotePublishAsync(Grpc.Core.CallOptions)", new XmlComment(@"publish the event to the relevant remote server that's running in HubMode.EventBroker mode.", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"call options", null, false)], null));
            cache.Add(@"T:FastEndpoints.IHasServerCallContext", new XmlComment(@"implement this interface on command handler classes in order to access the ServerCallContext IHasServerCallContext.ServerCallContext", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EventExtensions.Broadcast``1(``0)", new XmlComment(@"broadcast/publish an event to all remote subscribers.
this method should only be called when the server is running in HubMode.EventPublisher hub mode", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.EventHubExceptionReceiver", new XmlComment(@"inherit this class and override it's methods in order to receive event hub exceptions.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnRestoreSubscriberIDsError(System.Type,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble restoring event subscribers.", null, null, null, null, false, null, [new XmlParameterComment(@"eventType", @"the type of the event", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the subscriber were attempted to be retrieved", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnGetNextBatchError``1(System.String,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble retrieving the next batch of event records.", null, null, null, null, false, null, [new XmlParameterComment(@"subscriberID", @"the unique ID of the subscriber", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the operation was attempted", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnMarkEventAsCompleteError``1(FastEndpoints.IEventStorageRecord,System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble marking an event record as complete.", null, null, null, null, false, null, [new XmlParameterComment(@"record", @"the event storage record that was supposed to be marked complete", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the record was attempted to be marked complete", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnStoreEventRecordsError``1(System.Collections.Generic.IEnumerable{FastEndpoints.IEventStorageRecord},System.Int32,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble persisting event storage records.", null, null, null, null, false, null, [new XmlParameterComment(@"records", @"the event storage records that were supposed to be persisted", null, false), new XmlParameterComment(@"attemptCount", @"the number of times the operation was attempted", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnInMemoryQueueOverflow``1(FastEndpoints.IEventStorageRecord,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the default in-memory storage provider's internal queue for the given event type has been stagnant and in an overflow state.", null, null, null, null, false, null, [new XmlParameterComment(@"record", @"the event storage record that was supposed to be added to the queue", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiver.OnSerializeEventError``1(``0,System.Exception,System.Threading.CancellationToken)", new XmlComment(@"this method is triggered when the storage provider has trouble serializing an event object calling the
IEventStorageRecord.void IEventStorageRecord.SetEvent&lt;TEvent&gt;(TEvent @event) method.", null, null, null, null, false, null, [new XmlParameterComment(@"event", @"the event object that failed to serialize", null, false), new XmlParameterComment(@"exception", @"the actual exception that was thrown by the operation", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.EventHubExceptionReceiverExtensions.AddEventHubExceptionReceiver``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(@"register a custom exception receiver for receiving event hub exceptions.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HubMode", new XmlComment(@"enum for specifying which mode the event hub should be running in.", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.HubMode.EventPublisher", new XmlComment(@"this server/application itself is the sole publisher of events. no external publishers will be accepted. this is the default mode.", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.HubMode.EventBroker", new XmlComment(@"enable remote event publishers to send events to this server which will be relayed to the connected subscribers.
this mode also allows this server itself to publish events as well.", null, null, null, null, false, null, null, null));
            cache.Add(@"F:FastEndpoints.HubMode.RoundRobin", new XmlComment(@"with this mode events will only be delivered to just one of the subscribers connected to the hub in a round robin fashion.
if for example, there's two subscribers (A and B) connected, event 1 will be delivered to subscriber A.
event 2 will be delivered to subscriber B. event 3 will be delivered to subscriber A again and so on.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.IEventHubStorageProvider`1", new XmlComment(@"interface for implementing a storage provider for event hub app (gRPC server)", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.IEventHubStorageProvider`1.RestoreSubscriberIDsForEventTypeAsync(FastEndpoints.SubscriberIDRestorationParams{`0})", new XmlComment(@"this method will only be called once (for each event type) on app startup. if there are any pending records on storage from a previous app run,
simply return a collection of unique subscriber IDs.", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find relevant event records from your database", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventHubStorageProvider`1.StoreEventsAsync(System.Collections.Generic.IEnumerable{`0},System.Threading.CancellationToken)", new XmlComment(@"            store the event storage records however you please. ideally on a nosql database.
            WARNING: make sure to use a transaction or batch insert to ensure all the records are committed in one go.
if only some of the records succeed in being stored, it could lead to duplicate events being published due to the built-in retry mechanism.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"the event storage records which contains the actual event objects as well as some metadata", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventHubStorageProvider`1.GetNextBatchAsync(FastEndpoints.PendingRecordSearchParams{`0})", new XmlComment(@"fetch the next batch of pending event storage records that need to be processed.", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find the next batch of event records from your database", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventHubStorageProvider`1.MarkEventAsCompleteAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"mark the event storage record as complete by either replacing the entity on storage with the supplied instance or
simply update the bool IEventStorageRecord.IsComplete field to true with a partial update operation.", null, null, null, null, false, null, [new XmlParameterComment(@"r", @"", null, false), new XmlParameterComment(@"ct", @"cancellation token", null, false)], null));
            cache.Add(@"M:FastEndpoints.IEventHubStorageProvider`1.PurgeStaleRecordsAsync(FastEndpoints.StaleRecordSearchParams{`0})", new XmlComment(@"            this method will be called hourly. implement this method to remove stale records (completed or expired) from storage.
            or instead of removing them, you can move them to some other location (dead-letter-queue maybe) or for inspection by a human.
            or if you'd like to retry expired events, update the DateTime IEventStorageRecord.ExpireOn field to a future date/time.
            NOTE: the default match criteria is:
```r =&gt; r.IsComplete || DateTime.UtcNow &gt;= r.ExpireOn```", null, null, null, null, false, null, [new XmlParameterComment(@"parameters", @"use these supplied search parameters to find relevant event records from your database", null, false)], null));
            cache.Add(@"T:FastEndpoints.SubscriberIDRestorationParams`1", new XmlComment(@"parameters to use in finding subscriber IDs to restore", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SubscriberIDRestorationParams`1.EventType", new XmlComment(@"the type name of the events to search for which correlates to string IEventStorageRecord.EventType", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SubscriberIDRestorationParams`1.Match", new XmlComment(@"a boolean lambda expression to match pending records.
```r =&gt; r.EventType == ""xxx"" &amp;&amp; !r.IsComplete &amp;&amp; DateTime.UtcNow &lt;= r.ExpireOn)```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SubscriberIDRestorationParams`1.Projection", new XmlComment(@"member expression to select/project the UNIQUE string IEventStorageRecord.SubscriberID values.
```e =&gt; e.SubscriberID```", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.SubscriberIDRestorationParams`1.CancellationToken", new XmlComment(@"a cancellation token", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HandlerOptions`2", new XmlComment(@"handler registration options", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerOptions`2.Register``2", new XmlComment(@"registers a ""void"" command handler this server is hosting.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerOptions`2.Register``3", new XmlComment(@"registers a ""unary"" command handler this server is hosting.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerOptions`2.RegisterServerStream``3", new XmlComment(@"registers a ""server stream"" command handler this server is hosting.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerOptions`2.RegisterClientStream``3", new XmlComment(@"registers a ""client stream"" command handler this server is hosting.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerOptions`2.RegisterEventHub``1(FastEndpoints.HubMode)", new XmlComment(@"registers an ""event hub"" that broadcasts events of the given type to all remote subscribers in an asynchronous manner", null, null, null, null, false, null, [new XmlParameterComment(@"mode", @"the operation mode of this event hub", null, false)], null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.AddHandlerServer(Microsoft.AspNetCore.Builder.WebApplicationBuilder,System.Action{Grpc.AspNetCore.Server.GrpcServiceOptions})", new XmlComment(@"            configure the handler server which will host a collection of command handlers and event hubs. this should only be called once per application.
            IMPORTANT: specify which handlers/hubs this server will be hosting via
IEndpointRouteBuilder HandlerServerExtensions.MapHandlers&lt;TStorageRecord, TStorageProvider&gt;(IEndpointRouteBuilder b, Action&lt;HandlerOptions&lt;TStorageRecord, TStorageProvider&gt;&gt; h) method.", null, null, null, null, false, null, [new XmlParameterComment(@"bld", @"", null, false), new XmlParameterComment(@"o", @"optional grpc service settings", null, false)], null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.AddHandlerServer(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Grpc.AspNetCore.Server.GrpcServiceOptions})", new XmlComment(@"            configure the handler server which will host a collection of command handlers. this should only be called once per application.
            IMPORTANT: specify which handlers this server will be hosting via
IEndpointRouteBuilder HandlerServerExtensions.MapHandlers&lt;TStorageRecord, TStorageProvider&gt;(IEndpointRouteBuilder b, Action&lt;HandlerOptions&lt;TStorageRecord, TStorageProvider&gt;&gt; h) method.", null, null, null, null, false, null, [new XmlParameterComment(@"sc", @"", null, false), new XmlParameterComment(@"o", @"optional grpc service settings", null, false)], null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.MapHandlers(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.Action{FastEndpoints.HandlerOptions{FastEndpoints.InMemoryEventStorageRecord,FastEndpoints.InMemoryEventHubStorage}})", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.MapHandlers``2(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.Action{FastEndpoints.HandlerOptions{``0,``1}})", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.HandlerServerExtensions.<G>$AA6A55FA96EEB935F04A86FBF0CC54DA.<M>$AE21605245F75F0E887A7AEEA47FF5B0", new XmlComment(null, null, null, null, null, false, null, [new XmlParameterComment(@"b", @"", null, false)], null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.<G>$AA6A55FA96EEB935F04A86FBF0CC54DA.MapHandlers(System.Action{FastEndpoints.HandlerOptions{FastEndpoints.InMemoryEventStorageRecord,FastEndpoints.InMemoryEventHubStorage}})", new XmlComment(@"specify which handlers/event hubs this server will be hosting. the in-memory storage provider will be used.", null, null, null, null, false, null, [new XmlParameterComment(@"h", @"handler options", null, false)], null));
            cache.Add(@"M:FastEndpoints.HandlerServerExtensions.<G>$AA6A55FA96EEB935F04A86FBF0CC54DA.MapHandlers``2(System.Action{FastEndpoints.HandlerOptions{``0,``1}})", new XmlComment(@"specify which handlers/event hubs this server will be hosting together with a custom storage provider", null, null, null, null, false, null, [new XmlParameterComment(@"h", @"handler options", null, false)], null));
            cache.Add(@"M:FastEndpoints.KestrelExtensions.ListenInterProcess(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions,System.String,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})", new XmlComment(@"enable inter-process-communication via unix domain sockets instead of tcp transport when everything is running on the same machine.
a unix socket will be created with the provided serviceName", null, null, null, null, false, null, [new XmlParameterComment(@"ko", @"", null, false), new XmlParameterComment(@"serviceName", @"a unique name to identity this service. clients must use the same name in order to connect to this server with the
`.MapRemote()` call.", null, false), new XmlParameterComment(@"o", @"kestrel listen options", null, false)], null));

            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.AddAuthenticationJwtBearer(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FastEndpoints.Security.JwtSigningOptions},System.Action{Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions})", new XmlComment(@"configure and enable jwt bearer authentication", null, null, null, null, false, null, [new XmlParameterComment(@"signingOptions", @"an action to configure JwtSigningOptions", null, false), new XmlParameterComment(@"bearerOptions", @"an action to configure JwtBearerOptions", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.AddAuthenticationCookie(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.TimeSpan,System.Action{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions})", new XmlComment(@"configure and enable cookie based authentication", null, null, null, null, false, null, [new XmlParameterComment(@"validFor", @"specify how long the created cookie is valid for with a TimeSpan", null, false), new XmlParameterComment(@"options", @"optional action for configuring cookie authentication options", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.HasPermission(System.Security.Claims.ClaimsPrincipal,System.String)", new XmlComment(@"returns true of the current user principal has a given permission code.", null, null, null, null, false, null, [new XmlParameterComment(@"permissionCode", @"the permission code to check for", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.HasClaimType(System.Security.Claims.ClaimsPrincipal,System.String)", new XmlComment(@"determines if the current user principal has the given claim type", null, null, null, null, false, null, [new XmlParameterComment(@"claimType", @"the claim type to check for", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.ClaimValue(System.Security.Claims.ClaimsPrincipal,System.String)", new XmlComment(@"get the claim value for a given claim type of the current user principal. if the user doesn't have the requested claim type, a null will be returned.", null, null, null, null, false, null, [new XmlParameterComment(@"claimType", @"the claim type to look for", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.Add(System.Collections.Generic.List{System.Security.Claims.Claim},System.Security.Claims.Claim[])", new XmlComment(@"adds multiple Claims to the list.", null, null, null, null, false, null, [new XmlParameterComment(@"claims", @"the Claims to append to the list.", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.Add(System.Collections.Generic.List{System.Security.Claims.Claim},System.ValueTuple{System.String,System.String}[])", new XmlComment(@"adds multiple Claims to the list.", null, null, null, null, false, null, [new XmlParameterComment(@"claims", @"the claim `Type` &amp; `Value` tuples to add to the list.", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.AuthExtensions.Add(System.Collections.Generic.List{System.String},System.String[])", new XmlComment(@"adds multiple strings to a list.", null, null, null, null, false, null, [new XmlParameterComment(@"values", @"the strings to append to the list.", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.CookieAuth.SignInAsync(System.Action{FastEndpoints.UserPrivileges},System.Action{Microsoft.AspNetCore.Authentication.AuthenticationProperties})", new XmlComment(@"creates the auth cookie and adds it to the current http response", null, null, null, null, false, null, [new XmlParameterComment(@"privileges", @"the privileges to be assigned to the user such as claims, permissions, and roles", null, false), new XmlParameterComment(@"properties", @"an optional action to configure authentication properties", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.CookieAuth.SignOutAsync(System.Action{Microsoft.AspNetCore.Authentication.AuthenticationProperties})", new XmlComment(@"signs the user out from the cookie authentication scheme", null, null, null, null, false, null, [new XmlParameterComment(@"properties", @"an optional action to configure authentication properties", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.JwtBearer.CreateToken(System.Action{FastEndpoints.Security.JwtCreationOptions})", new XmlComment(@"generates jwt tokens with supplied settings.", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"action to configure jwt creation options.", null, false)], null));
            cache.Add(@"T:FastEndpoints.Security.JwtCreationOptions", new XmlComment(@"options for creating jwt tokens", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.SigningKey", new XmlComment(@"the key used to sign jwts symmetrically or the base64 encoded private-key when jwts are signed asymmetrically.", null, @"the key can be in PEM format. make sure to set bool JwtCreationOptions.KeyIsPemEncoded to `true` if the key is PEM encoded.", null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.SigningStyle", new XmlComment(@"specifies how tokens are to be signed. symmetrically or asymmetrically.", null, @"don't forget to set an appropriate string JwtCreationOptions.SigningAlgorithm if changing to TokenSigningStyle.Symmetric", null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.SigningAlgorithm", new XmlComment(@"security algorithm used to sign keys.", null, @"defaults to HmacSha256 for symmetric keys. don't forget to set an appropriate algorithm when changing TokenSigningStyle JwtCreationOptions.SigningStyle to
TokenSigningStyle.Asymmetric", null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.KeyIsPemEncoded", new XmlComment(@"specifies whether the key is pem encoded.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.AsymmetricKidGenerator", new XmlComment(@"if specified, this function will be used to generate a `kid` for asymmetric key generation.
the `string` value returned from this function will be set on the RsaSecurityKey.<see cref=""!:RsaSecurityKey.KeyId"" /> property.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.User", new XmlComment(@"specify the privileges of the user
NOTE: this should be specified at the time of jwt creation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.Audience", new XmlComment(@"the value for the 'audience' claim.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.Issuer", new XmlComment(@"the issuer", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.ExpireAt", new XmlComment(@"the value of the 'expiration' claim. should be in utc.
NOTE: this should be set at the time of token creation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtCreationOptions.CompressionAlgorithm", new XmlComment(@"the compression algorithm  compressing the token payload.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Security.JwtSigningOptions", new XmlComment(@"jwt signing options for consuming jwts.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtSigningOptions.SigningKey", new XmlComment(@"the key used to sign jwts symmetrically or the base64 encoded public-key when jwts are signed asymmetrically.
the key can be optional when used to verify tokens issued by an idp where public key retrieval happens dynamically.", null, @"the key can be in PEM format. make sure to set bool JwtSigningOptions.KeyIsPemEncoded to `true` if the key is PEM encoded.", null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtSigningOptions.SigningStyle", new XmlComment(@"specifies how tokens were signed. symmetrically or asymmetrically.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.JwtSigningOptions.KeyIsPemEncoded", new XmlComment(@"specifies whether the key is pem encoded.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.JwtSigningOptions.UpdateSigningKey(System.String)", new XmlComment(@"call this method to update the jwt signing key during runtime. all future token verifications will use the supplied key.", null, null, null, null, false, null, [new XmlParameterComment(@"key", @"the new jwt signing key to use for generating a SecurityKey", null, false)], null));
            cache.Add(@"T:FastEndpoints.Security.Permissions", new XmlComment(@"            inherit from this class and define your applications permissions as `public const string````public const string Inventory_Create_Item = ""100"";
public const string Inventory_Retrieve_Item = ""101"";
public const string Inventory_Update_Item = ""102"";
public const string Inventory_Delete_Item = ""103"";```", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.NamesFor(System.Collections.Generic.IEnumerable{System.String})", new XmlComment(@"gets a list of permission names for the given list of permission codes", null, null, null, null, false, null, [new XmlParameterComment(@"codes", @"the permission codes to get the permission names for", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.CodesFor(System.Collections.Generic.IEnumerable{System.String})", new XmlComment(@"get a list of permission codes for a given list of permission names", null, null, null, null, false, null, [new XmlParameterComment(@"names", @"the permission names to get the codes for", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.PermissionFromName(System.String)", new XmlComment(@"get the permission tuple using it's name. returns null if not found", null, null, null, null, false, null, [new XmlParameterComment(@"permissionName", @"name of the permission", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.PermissionFromCode(System.String)", new XmlComment(@"get the permission tuple using it's code. returns null if not found", null, null, null, null, false, null, [new XmlParameterComment(@"permissionCode", @"code of the permission to get", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.AllNames", new XmlComment(@"get a list of all permission names", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.AllCodes", new XmlComment(@"get a list of all permission codes", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.Permissions.GetEnumerator", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.TokenSigningKey", new XmlComment(@"specifies the secret key used to sign the jwt.
an exception will be thrown if a value is not specified when global JwtCreationOptions is not configured.
i.e. if global JwtCreationOptions is configured, you don't need to set the following properties because the values will come from the globally
configured settings:
string? RefreshServiceOptions.TokenSigningKey / TokenSigningStyle RefreshServiceOptions.TokenSigningStyle / string RefreshServiceOptions.TokenSigningAlgorithm / string? RefreshServiceOptions.Issuer / string? RefreshServiceOptions.Audience", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.TokenSigningStyle", new XmlComment(@"specifies the signing style of the jwt. default is symmetric.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.TokenSigningAlgorithm", new XmlComment(@"security algo used to sign tokens.
defaults to HmacSha256 for symmetric keys.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.SigningKeyIsPemEncoded", new XmlComment(@"specifies whether the key is pem encoded.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.AccessTokenValidity", new XmlComment(@"specifies how long the access token should be valid for. default is 5 minutes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.RefreshTokenValidity", new XmlComment(@"specifies how long the refresh token should be valid for. default is 4 hours.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.Issuer", new XmlComment(@"specifies the token issuer", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.Audience", new XmlComment(@"specifies the token audience", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.RefreshServiceOptions.TokenCompressionAlgorithm", new XmlComment(@"the compression algorithm  compressing the token payload.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.RefreshServiceOptions.Endpoint(System.String,System.Action{FastEndpoints.EndpointDefinition})", new XmlComment(@"endpoint configuration action", null, null, null, null, false, null, [new XmlParameterComment(@"refreshEndpointRoute", @"the route of the refresh token endpoint", null, false), new XmlParameterComment(@"ep", @"the action to be performed on the endpoint definition", null, false)], null));
            cache.Add(@"T:FastEndpoints.Security.RefreshTokenService`2", new XmlComment(@"implement this class to define your own refresh token endpoints.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.Configure", new XmlComment(@"WARNING: do not call this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.HandleAsync(`0,System.Threading.CancellationToken)", new XmlComment(@"WARNING: do not call this method!", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.Setup(System.Action{FastEndpoints.Security.RefreshServiceOptions})", new XmlComment(@"configure the refresh token service options", null, null, null, null, false, null, [new XmlParameterComment(@"options", @"action to be performed on the refresh service options object", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.OnBeforeInitialTokenCreationAsync(FastEndpoints.Security.JwtCreationOptions,System.Object)", new XmlComment(@"a hook for modifying jwt creation options per request when a login request comes in. this method is called right before the actual jwt token is created
allowing you to override token creation parameters per request if needed.", null, null, null, null, false, null, [new XmlParameterComment(@"jwtOptions", @"jwt token creation options which you can modify per request", null, false), new XmlParameterComment(@"request", @"the request dto. maybe null unless you supply it to the Task&lt;TResponse&gt; Endpoint&lt;TRequest, TResponse&gt;.CreateTokenWith&lt;TService&gt;(string userId, Action&lt;UserPrivileges&gt; userPrivileges, TRequest? request = default(TRequest?)) method.", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.OnAfterInitialTokenCreationAsync(System.Object,`1)", new XmlComment(@"a hook for modifying the created token response when a login request comes in.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto. maybe null unless you supply it to the Task&lt;TResponse&gt; Endpoint&lt;TRequest, TResponse&gt;.CreateTokenWith&lt;TService&gt;(string userId, Action&lt;UserPrivileges&gt; userPrivileges, TRequest? request = default(TRequest?)) method.", null, false), new XmlParameterComment(@"response", @"the token response dto that is created", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.OnBeforeRenewalTokenCreationAsync(FastEndpoints.Security.JwtCreationOptions,`0)", new XmlComment(@"a hook for modifying jwt creation options per request when a renewal request comes in. this method is called right before the actual jwt token is created
allowing you to override token creation parameters per request if needed.", null, null, null, null, false, null, [new XmlParameterComment(@"jwtOptions", @"jwt token creation options which you can modify per request", null, false), new XmlParameterComment(@"request", @"the request dto. maybe null unless you supply it to the Task&lt;TResponse&gt; Endpoint&lt;TRequest, TResponse&gt;.CreateTokenWith&lt;TService&gt;(string userId, Action&lt;UserPrivileges&gt; userPrivileges, TRequest? request = default(TRequest?)) method.", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.OnAfterRenewalTokenCreationAsync(`0,`1)", new XmlComment(@"a hook for modifying the created token response when a renewal request comes in.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto. maybe null unless you supply it to the Task&lt;TResponse&gt; Endpoint&lt;TRequest, TResponse&gt;.CreateTokenWith&lt;TService&gt;(string userId, Action&lt;UserPrivileges&gt; userPrivileges, TRequest? request = default(TRequest?)) method.", null, false), new XmlParameterComment(@"response", @"the token response dto that is created", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.PersistTokenAsync(`1)", new XmlComment(@"this method will be called whenever a new access/refresh token pair is being generated.
store the tokens and expiry dates however you wish for the purpose of verifying future refresh requests.", null, null, null, null, false, null, [new XmlParameterComment(@"response", @"the response dto containing the tokens that's about to be sent to the requesting client", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.RefreshRequestValidationAsync(`0)", new XmlComment(@"validate the incoming refresh request by checking the token and expiry against the previously stored data.
if the token is not valid and a new token pair should not be created, simply add validation errors using the `AddError()` method.
the failures you add will be sent to the requesting client. if no failures are added, validation passes and a new token pair will be created and sent to
the client.", null, null, null, null, false, null, [new XmlParameterComment(@"req", @"the incoming refresh request dto", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.SetRenewalPrivilegesAsync(`0,FastEndpoints.UserPrivileges)", new XmlComment(@"specify the user privileges to be embedded in the jwt when a refresh request is received and validation has passed.
this only applies to renewal/refresh requests received to the refresh endpoint and not the initial jwt creation.", null, null, null, null, false, null, [new XmlParameterComment(@"request", @"the request dto received from the client", null, false), new XmlParameterComment(@"privileges", @"the user privileges to be embedded in the jwt such as roles/claims/permissions", null, false)], null));
            cache.Add(@"M:FastEndpoints.Security.RefreshTokenService`2.CreateCustomToken``1(System.String,System.Action{FastEndpoints.UserPrivileges},System.Func{`1,``0},System.Boolean,System.Object)", new XmlComment(@"create a token response and map it to a different type. useful if you need to create the token manually by yourself.", null, null, null, null, false, null, [new XmlParameterComment(@"userId", @"the id of the user to create the token for", null, false), new XmlParameterComment(@"privileges", @"the user privileges to be embedded in the jwt such as roles/claims/permissions", null, false), new XmlParameterComment(@"map", @"a func that maps properties from TResponse to T", null, false), new XmlParameterComment(@"isRenewal", @"specify if this is an initial login request or a renewal/refresh request", null, false), new XmlParameterComment(@"request", @"the request dto", null, false)], null));
            cache.Add(@"T:FastEndpoints.Security.TokenRequest", new XmlComment(@"base dto for access/refresh token renewal requests", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.TokenRequest.UserId", new XmlComment(@"unique identifier of a user", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.TokenRequest.RefreshToken", new XmlComment(@"a single-use refresh token which will be valid for the duration specified by DateTime TokenResponse.RefreshExpiry", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Security.TokenResponse", new XmlComment(@"base dto for access/refresh token responses", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.TokenResponse.AccessToken", new XmlComment(@"the jwt access token which will be valid for the duration specified by DateTime TokenResponse.AccessExpiry", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.TokenResponse.AccessExpiry", new XmlComment(@"the expiry date-time of the access token", null, null, null, null, false, null, null, null));
            cache.Add(@"P:FastEndpoints.Security.TokenResponse.RefreshExpiry", new XmlComment(@"the expiry date-time of the refresh token", null, null, null, null, false, null, null, null));
            cache.Add(@"M:FastEndpoints.Security.JwtRevocationExtensions.UseJwtRevocation``1(Microsoft.AspNetCore.Builder.IApplicationBuilder)", new XmlComment(@"adds an implementation of JwtRevocationMiddleware to the pipeline for the purpose of checking incoming jwt bearer tokens for validity.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:FastEndpoints.Security.JwtRevocationMiddleware", new XmlComment(@"abstract class for implementing a jwt revocation middleware", null, null, null, null, false, null, [new XmlParameterComment(@"next", @"the next request delegate to execute", null, false)], null));
            cache.Add(@"T:FastEndpoints.Security.TokenSigningStyle", new XmlComment(@"token signing style enum", null, null, null, null, false, null, null, null));

            cache.Add(@"T:Web.Hostings.AotResponseBufferingMiddleware", new XmlComment(@"AOT Response Buffering Middleware for Native AOT FastEndpoints compatibility.

Problem: FastEndpoints registers routes with app.MapMethods(..., lambda =&gt; Task).
ASP.NET Core's EndpointMiddleware awaits the Task and tries to serialize the result (VoidTaskResult).
In Native AOT, this triggers: ""JsonPropertyInfo`1[System.Threading.Tasks.VoidTaskResult] is missing native code or metadata""

Why pre-configuration doesn't work:
- ASP.NET Core's HttpResponseJsonExtensions uses its own internal JsonSerializerOptions
- Configuring FastEndpoints' serializer options doesn't affect ASP.NET Core's built-in JSON middleware
- The VoidTaskResult type is internal to .NET and cannot be registered in a JsonSerializerContext

Solution: This middleware catches and suppresses the VoidTaskResult exception when the response
was already successfully written. This is safe because:
1. Our custom ResponseSerializer already wrote the actual response data
2. The exception occurs AFTER the response is written, not during
3. The buffer contains the complete, valid response

Performance: Minimal overhead. Exception filters have near-zero cost when no exception occurs.
When the exception does occur, we simply suppress it - no re-throw or stack unwinding.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Admin.Login.Request", new XmlComment(@"Derived request adding Web-specific properties.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Binding.Multipart.UploadRequest", new XmlComment(@"Derived request adding server-only IFormFile and [FromForm] attributes.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Domain.Customers.CreateWithPropertiesDI.Request", new XmlComment(@"Derived request with Web-specific binding attributes.
Only overrides properties that need [From], [HasPermission], etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Domain.Customers.Create.Request", new XmlComment(@"Derived request with Web-specific binding attributes.
Only overrides properties that need [From], [HasPermission], etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Domain.Customers.Update.Request", new XmlComment(@"Derived request with Web-specific binding attributes.
Only overrides properties that need [FromClaim], [QueryParam], etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Domain.Inventory.Manage.Create.Request", new XmlComment(@"Derived request with Web-specific binding attributes.
Only overrides properties that need [From], [FromClaim], etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Inventory.Manage.Delete.Request", new XmlComment(@"Derived request with Web-specific [DefaultValue] attribute.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Inventory.Manage.Update.Request", new XmlComment(@"Derived request with Web-specific binding attributes.
Only overrides properties that need [From], etc.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Uploads.Image.SaveTyped.Request", new XmlComment(@"Derived request from Shared base with server-only IFormFile properties.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Uploads.Image.Save.Request", new XmlComment(@"Derived request from Shared base.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Web.Infrastructure.AppEnv.EnvironmentName", new XmlComment(@"The logical environment name (for example: ""Development"", ""Staging"", or ""Production"").", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Web.Infrastructure.AppEnv.IsDevelopment", new XmlComment(@"True when string AppEnv.EnvironmentName equals ""Development"" (case-insensitive).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Web.Infrastructure.AppEnv.IsProduction", new XmlComment(@"True when string AppEnv.EnvironmentName equals ""Production"" (case-insensitive).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Web.Infrastructure.AppEnv.IsStaging", new XmlComment(@"True when string AppEnv.EnvironmentName equals ""Staging"" (case-insensitive).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Admin.Login.Request.GetterOnlyProp", new XmlComment(@"Server-only: getter-only property for testing", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Binding.Multipart.UploadRequest.File", new XmlComment(@"Server-only: actual file from multipart form", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Domain.Customers.CreateWithPropertiesDI.Request.cID", new XmlComment(@"Route parameter for customer ID", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Domain.Customers.Create.Request.cID", new XmlComment(@"Route parameter for customer ID (bound from route /customer/{cID}/new/{SourceID})", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Domain.Sales.Orders.Create.Request.GuidTest", new XmlComment(@"this is a guid property description", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Domain.Sales.Orders.Retrieve.Request.TenantID", new XmlComment(@"this is the tenant id", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.DupeParamBindingForIEnumerableProps.Request.Dates", new XmlComment(null, null, null, null, null, false, [@"[""2020-10-10""]"], null, null));
            cache.Add(@"P:TestCases.FromBodyJsonBinding.Product.Id", new XmlComment(@"product id goes here", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.FromBodyJsonBinding.Product.Name", new XmlComment(@"this is the name of the product", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.FromBodyJsonBinding.Product.Price", new XmlComment(@"product price goes here", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.JsonArrayBindingForIEnumerableProps.Request.Dates", new XmlComment(null, null, null, null, null, false, [@"[""2020-10-10""]"], null, null));
            cache.Add(@"P:TestCases.QueryObjectBindingTest.Request.String", new XmlComment(@"this is a string prop xml comment", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.QueryParamBindingInEpWithoutReq.Response.OtherID", new XmlComment(@"optional other id", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.RouteBindingInEpWithoutReq.Response.OtherID", new XmlComment(@"optional other id", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.RouteBindingTest.Request.String", new XmlComment(@"this is a string prop xml comment", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.RouteBindingTest.Request.FromBody", new XmlComment(@"frm body xml comment", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.PlainTextRequestTest.Request.Id", new XmlComment(@"id of the plain text request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.GlobalRoutePrefixOverrideTest.Request.Id", new XmlComment(@"id of the plain text request", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.RateLimitTests.Response.OtherID", new XmlComment(@"optional other id", null, null, null, null, false, null, null, null));
            cache.Add(@"P:TestCases.DataAnnotationCompliant.Request.Id", new XmlComment(@"id of the plain text request", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Web.Hostings.CoreHosting.UseAotResponseBuffering(Microsoft.AspNetCore.Builder.IApplicationBuilder)", new XmlComment(@"Adds the AOT response buffering middleware that catches VoidTaskResult serialization exceptions.
This must be registered early in the pipeline, before FastEndpoints.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Domain.Inventory.List.Recent.Endpoint.HandleAsync(System.Threading.CancellationToken)", new XmlComment(@"Handles the retrieval of recent inventory items for a specified category.", null, @"This endpoint is protected and requires the requesting user to have either the Admin or TestRole role.
Additionally, the AdminOnly policy must be satisfied.", @"A task that represents the asynchronous operation, containing the response with the recent inventory items.", null, false, null, [new XmlParameterComment(@"t", @"Cancellation token.", null, false)], null));

            return cache;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file static class DocumentationCommentIdHelper
    {
        /// <summary>
        /// Generates a documentation comment ID for a type.
        /// Example: T:Namespace.Outer+Inner`1 becomes T:Namespace.Outer.Inner`1
        /// </summary>
        public static string CreateDocumentationId(this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            return "T:" + GetTypeDocId(type, includeGenericArguments: false, omitGenericArity: false);
        }

        /// <summary>
        /// Generates a documentation comment ID for a property.
        /// Example: P:Namespace.ContainingType.PropertyName or for an indexer P:Namespace.ContainingType.Item(System.Int32)
        /// </summary>
        public static string CreateDocumentationId(this PropertyInfo property)
        {
            if (property == null)
            {
                throw new ArgumentNullException(nameof(property));
            }

            var sb = new StringBuilder();
            sb.Append("P:");

            if (property.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(property.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');
            sb.Append(property.Name);

            // For indexers, include the parameter list.
            var indexParams = property.GetIndexParameters();
            if (indexParams.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < indexParams.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    sb.Append(GetTypeDocId(indexParams[i].ParameterType, includeGenericArguments: true, omitGenericArity: false));
                }
                sb.Append(')');
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a property given its container type and property name.
        /// Example: P:Namespace.ContainingType.PropertyName
        /// </summary>
        public static string CreateDocumentationId(Type containerType, string propertyName)
        {
            if (containerType == null)
            {
                throw new ArgumentNullException(nameof(containerType));
            }
            if (string.IsNullOrEmpty(propertyName))
            {
                throw new ArgumentException("Property name cannot be null or empty.", nameof(propertyName));
            }

            var sb = new StringBuilder();
            sb.Append("P:");
            sb.Append(GetTypeDocId(containerType, includeGenericArguments: false, omitGenericArity: false));
            sb.Append('.');
            sb.Append(propertyName);

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a method (or constructor).
        /// For example:
        ///   M:Namespace.ContainingType.MethodName(ParamType1,ParamType2)~ReturnType
        ///   M:Namespace.ContainingType.#ctor(ParamType)
        /// </summary>
        public static string CreateDocumentationId(this MethodInfo method)
        {
            if (method == null)
            {
                throw new ArgumentNullException(nameof(method));
            }

            var sb = new StringBuilder();
            sb.Append("M:");

            // Append the fully qualified name of the declaring type.
            if (method.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(method.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');

            // Append the method name, handling constructors specially.
            if (method.IsConstructor)
            {
                sb.Append(method.IsStatic ? "#cctor" : "#ctor");
            }
            else
            {
                sb.Append(method.Name);
                if (method.IsGenericMethod)
                {
                    sb.Append("``");
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", method.GetGenericArguments().Length);
                }
            }

            // Append the parameter list, if any.
            var parameters = method.GetParameters();
            if (parameters.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < parameters.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    // Omit the generic arity for the parameter type.
                    sb.Append(GetTypeDocId(parameters[i].ParameterType, includeGenericArguments: true, omitGenericArity: true));
                }
                sb.Append(')');
            }

            // Append the return type after a '~' (if the method returns a value).
            if (method.ReturnType != typeof(void))
            {
                sb.Append('~');
                // Omit the generic arity for the return type.
                sb.Append(GetTypeDocId(method.ReturnType, includeGenericArguments: true, omitGenericArity: true));
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation ID string for a type.
        /// This method handles nested types (replacing '+' with '.'),
        /// generic types, arrays, pointers, by-ref types, and generic parameters.
        /// The <paramref name="includeGenericArguments"/> flag controls whether
        /// constructed generic type arguments are emitted, while <paramref name="omitGenericArity"/>
        /// controls whether the generic arity marker (e.g. "`1") is appended.
        /// </summary>
        private static string GetTypeDocId(Type type, bool includeGenericArguments, bool omitGenericArity)
        {
            if (type.IsGenericParameter)
            {
                // Use `` for method-level generic parameters and ` for type-level.
                if (type.DeclaringMethod != null)
                {
                    return "``" + type.GenericParameterPosition;
                }
                else if (type.DeclaringType != null)
                {
                    return "`" + type.GenericParameterPosition;
                }
                else
                {
                    return type.Name;
                }
            }

            if (type.IsGenericType)
            {
                Type genericDef = type.GetGenericTypeDefinition();
                string fullName = genericDef.FullName ?? genericDef.Name;

                var sb = new StringBuilder(fullName.Length);

                // Replace '+' with '.' for nested types
                for (var i = 0; i < fullName.Length; i++)
                {
                    char c = fullName[i];
                    if (c == '+')
                    {
                        sb.Append('.');
                    }
                    else if (c == '`')
                    {
                        break;
                    }
                    else
                    {
                        sb.Append(c);
                    }
                }

                if (!omitGenericArity)
                {
                    int arity = genericDef.GetGenericArguments().Length;
                    sb.Append('`');
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", arity);
                }

                if (includeGenericArguments && !type.IsGenericTypeDefinition)
                {
                    var typeArgs = type.GetGenericArguments();
                    sb.Append('{');

                    for (int i = 0; i < typeArgs.Length; i++)
                    {
                        if (i > 0)
                        {
                            sb.Append(',');
                        }

                        sb.Append(GetTypeDocId(typeArgs[i], includeGenericArguments, omitGenericArity));
                    }

                    sb.Append('}');
                }

                return sb.ToString();
            }

            // For non-generic types, use FullName (if available) and replace nested type separators.
            return (type.FullName ?? type.Name).Replace('+', '.');
        }

        /// <summary>
        /// Normalizes a documentation comment ID to match the compiler-style format.
        /// Strips the return type suffix for ordinary methods but retains it for conversion operators.
        /// </summary>
        /// <param name="docId">The documentation comment ID to normalize.</param>
        /// <returns>The normalized documentation comment ID.</returns>
        public static string NormalizeDocId(string docId)
        {
            // Find the tilde character that indicates the return type suffix
            var tildeIndex = docId.IndexOf('~');
            if (tildeIndex == -1)
            {
                // No return type suffix, return as-is
                return docId;
            }

            // Check if this is a conversion operator (op_Implicit or op_Explicit)
            // For these operators, we need to keep the return type suffix
            if (docId.Contains("op_Implicit") || docId.Contains("op_Explicit"))
            {
                return docId;
            }

            // For ordinary methods, strip the return type suffix
            return docId.Substring(0, tildeIndex);
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file class XmlCommentOperationTransformer : IOpenApiOperationTransformer
    {
        public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
        {
            var methodInfo = context.Description.ActionDescriptor is ControllerActionDescriptor controllerActionDescriptor
                ? controllerActionDescriptor.MethodInfo
                : context.Description.ActionDescriptor.EndpointMetadata.OfType<MethodInfo>().SingleOrDefault();

            if (methodInfo is null)
            {
                return Task.CompletedTask;
            }
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(methodInfo.CreateDocumentationId()), out var methodComment))
            {
                if (methodComment.Summary is { } summary)
                {
                    operation.Summary = summary;
                }
                if (methodComment.Description is { } description)
                {
                    operation.Description = description;
                }
                if (methodComment.Remarks is { } remarks)
                {
                    operation.Description = remarks;
                }
                if (methodComment.Parameters is { Count: > 0})
                {
                    foreach (var parameterComment in methodComment.Parameters)
                    {
                        var parameterInfo = methodInfo.GetParameters().SingleOrDefault(info => info.Name == parameterComment.Name);
                        var operationParameter = operation.Parameters?.SingleOrDefault(parameter => parameter.Name == parameterComment.Name);
                        if (operationParameter is not null)
                        {
                            var targetOperationParameter = UnwrapOpenApiParameter(operationParameter);
                            targetOperationParameter.Description = parameterComment.Description;
                            if (parameterComment.Example is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                            targetOperationParameter.Deprecated = parameterComment.Deprecated;
                        }
                        else
                        {
                            var requestBody = operation.RequestBody;
                            if (requestBody is not null)
                            {
                                requestBody.Description = parameterComment.Description;
                                if (parameterComment.Example is { } jsonString)
                                {
                                    var content = requestBody?.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = jsonString.Parse();
                                    }
                                }
                            }
                        }
                    }
                }
                // Applies `<returns>` on XML comments for operation with single response value.
                if (methodComment.Returns is { } returns && operation.Responses is { Count: 1 })
                {
                    var response = operation.Responses.First();
                    response.Value.Description = returns;
                }
                // Applies `<response>` on XML comments for operation with multiple response values.
                if (methodComment.Responses is { Count: > 0} && operation.Responses is { Count: > 0 })
                {
                    foreach (var response in operation.Responses)
                    {
                        var responseComment = methodComment.Responses.SingleOrDefault(xmlResponse => xmlResponse.Code == response.Key);
                        if (responseComment is not null)
                        {
                            response.Value.Description = responseComment.Description;
                        }
                    }
                }
            }
            foreach (var parameterDescription in context.Description.ParameterDescriptions)
            {
                var metadata = parameterDescription.ModelMetadata;
                if (metadata is not null
                    && metadata.MetadataKind == ModelMetadataKind.Property
                    && metadata.ContainerType is { } containerType
                    && metadata.PropertyName is { } propertyName)
                {
                    var propertyDocId = DocumentationCommentIdHelper.CreateDocumentationId(containerType, propertyName);
                    if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyDocId), out var propertyComment))
                    {
                        var parameter = operation.Parameters?.SingleOrDefault(p => p.Name == metadata.Name);
                        var description = propertyComment.Summary;
                        if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                        {
                            description = $"{description}\n{propertyComment.Value}";
                        }
                        else if (string.IsNullOrEmpty(description))
                        {
                            description = propertyComment.Value;
                        }
                        if (parameter is null)
                        {
                            if (operation.RequestBody is not null)
                            {
                                operation.RequestBody.Description = description;
                                if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                                {
                                    var content = operation.RequestBody.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    var parsedExample = jsonString.Parse();
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = parsedExample;
                                    }
                                }
                            }
                            continue;
                        }
                        var targetOperationParameter = UnwrapOpenApiParameter(parameter);
                        if (targetOperationParameter is not null)
                        {
                            targetOperationParameter.Description = description;
                            if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                        }
                    }
                }
            }

            return Task.CompletedTask;
        }

        private static OpenApiParameter UnwrapOpenApiParameter(IOpenApiParameter sourceParameter)
        {
            if (sourceParameter is OpenApiParameterReference parameterReference)
            {
                if (parameterReference.Target is OpenApiParameter target)
                {
                    return target;
                }
                else
                {
                    throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
                }
            }
            else if (sourceParameter is OpenApiParameter directParameter)
            {
                return directParameter;
            }
            else
            {
                throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file class XmlCommentSchemaTransformer : IOpenApiSchemaTransformer
    {
        public Task TransformAsync(OpenApiSchema schema, OpenApiSchemaTransformerContext context, CancellationToken cancellationToken)
        {
            // Apply comments from the type
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(context.JsonTypeInfo.Type.CreateDocumentationId()), out var typeComment))
            {
                schema.Description = typeComment.Summary;
                if (typeComment.Examples?.FirstOrDefault() is { } jsonString)
                {
                    schema.Example = jsonString.Parse();
                }
            }

            if (context.JsonPropertyInfo is { AttributeProvider: PropertyInfo propertyInfo })
            {
                // Apply comments from the property
                if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyInfo.CreateDocumentationId()), out var propertyComment))
                {
                    var description = propertyComment.Summary;
                    if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                    {
                        description = $"{description}\n{propertyComment.Value}";
                    }
                    else if (string.IsNullOrEmpty(description))
                    {
                        description = propertyComment.Value;
                    }
                    if (schema.Metadata is null
                        || !schema.Metadata.TryGetValue("x-schema-id", out var schemaId)
                        || string.IsNullOrEmpty(schemaId as string))
                    {
                        // Inlined schema
                        schema.Description = description;
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Example = jsonString.Parse();
                        }
                    }
                    else
                    {
                        // Schema Reference
                        if (!string.IsNullOrEmpty(description))
                        {
                            schema.Metadata["x-ref-description"] = description;
                        }
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Metadata["x-ref-example"] = jsonString.Parse()!;
                        }
                    }
                }
            }
            return Task.CompletedTask;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file static class JsonNodeExtensions
    {
        public static JsonNode? Parse(this string? json)
        {
            if (json is null)
            {
                return null;
            }

            try
            {
                return JsonNode.Parse(json);
            }
            catch (JsonException)
            {
                try
                {
                    // If parsing fails, try wrapping in quotes to make it a valid JSON string
                    return JsonNode.Parse($"\"{json.Replace("\"", "\\\"")}\"");
                }
                catch (JsonException)
                {
                    return null;
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.2.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.2.0")]
    file static class GeneratedServiceCollectionExtensions
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "nSQFUq3APaeVurlQGldr7c8BAABEb2NzRmVhdHVyZS5jcw==")]
        public static IServiceCollection AddOpenApi(this IServiceCollection services, string documentName, Action<OpenApiOptions> configureOptions)
        {
            // This overload is not intercepted.
            return OpenApiServiceCollectionExtensions.AddOpenApi(services, documentName, options =>
            {
                options.AddSchemaTransformer(new XmlCommentSchemaTransformer());
                options.AddOperationTransformer(new XmlCommentOperationTransformer());
                configureOptions(options);
            });
        }

    }
}
